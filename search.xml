<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>netlify 部署hexo博客绑定自定义域名方法记录</title>
      <link href="/2019/12/26/netlify-bu-shu-hexo-bo-ke-fang-fa-ji-lu/"/>
      <url>/2019/12/26/netlify-bu-shu-hexo-bo-ke-fang-fa-ji-lu/</url>
      
        <content type="html"><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>github提供得gitpage可以基于本地hexo环境构建个人博客站点，而且速度很快。 但是有个致命问题，百度不收录gitpage 站点，原因据说是gitpage 屏蔽百度蜘蛛，由于个人站点大量被百度蜘蛛访问，导致github 负载增加，github所以屏蔽了百度。</p><p>导致结果： 网址不会被百度收录。</p><h1 id="寻找解决方案"><a href="#寻找解决方案" class="headerlink" title="寻找解决方案"></a>寻找解决方案</h1><p>参考文章：<a href="https://blog.csdn.net/grackanil/article/details/81196931" target="_blank" rel="noopener">https://blog.csdn.net/grackanil/article/details/81196931</a></p><h2 id="GitHub-Pages"><a href="#GitHub-Pages" class="headerlink" title="GitHub Pages"></a>GitHub Pages</h2><p>被设计为直接来源于GitHub仓库的个人、组织或项目主页。<br>提供静态网站托管服务<br>不支持服务端代码，比如 PHP、Ruby 或 Python<br>GitHub Pages 提供的域名可以支持 HTTPS 访问<br>可以配置自定义的域名，但是无法给自定义的域名配置 SSL ，HTTPS is not supported for GitHub Pages using custom domains. 查阅 Github Help，所有 GitHub Pages 网站（包括使用自定义域正确配置的网站）已经都支持 HTTPS 和 HTTPS 强制实施。<br>响应速度还是有点慢<br>网站仓库小于1GB，带宽限制 100GB/每月，构建限制10次/每小时</p><h2 id="Netlify"><a href="#Netlify" class="headerlink" title="Netlify"></a>Netlify</h2><p>不支持后台逻辑运算能力的网页<br>如果要部署 Hexo 大体思路是，通过 CLI (命令行界面)将 md 渲染为静态网站，然后通过 git 部署到 Git 平台，然后使用 Netlify 的 webhook 自动抓取部署<br>具有全球CDN、持续部署、一键HTTPS等优势<br>能通过客户端 JS 与可重用 API 可以带来动态功能，炫酷。<br>可以使用 Hugo 静态网站生成器和 Hetlify 网站自动化系统配合，以解决 Github Pages 的不支持 HTTPS 和 响应慢的问题</p><h2 id="Coding-Pages"><a href="#Coding-Pages" class="headerlink" title="Coding Pages"></a>Coding Pages</h2><p>由国内 Coding 提供<br>访问速度友好<br>可以做 GitHub Pages 和 Coding Pages 同时部署 Hexo，然后通过域名 DNS 解析，国外访问 GitHub Pages ，国内 访问 Coding Pages， 以优化访问速度<br>可以免费绑定多个自定义域名<br>自定义域名可以享有免费 SSL 证书，全站支持 HTTPS 协议<br>更新代码库就可以自动部署。服务器稳定，香港服务器国外支持也友好<br>新增动态页面部署<br>有一个小问题是，网站首页如果不放置官方『Hosted by Coding Pages』的链接，会系统添加中间『Hosted by Coding Pages』页面。<br>GitLab Pages 是由 GitLab 提供，旨在为 GitLab 工程、个人、groups 创建网站。<br>可以使用任何静态网站生成器，如 Jekyll、Middleman、Hexo、Hugo、Pelican等<br>可以配置自定义域名 HTTPS，需要的是上传证书</p><h2 id="Now"><a href="#Now" class="headerlink" title="Now"></a>Now</h2><p>不仅支持静态网站托管，也支持 JavaScript(Node.js) 或者 Docker 驱动的网站，<br>可以使用 CLI 或者链接 Git 仓库<br>支持自定义域名，开启 HTTPS<br>传输基于 HTTP/2<br>不需要安装 Git 等源代码控制工具，不需要设置 keys 或者 tokens<br>实时部署。<br>Firebase Hosting<br>只能 CLI<br>支持自定义域名并支持开启 HTTPS<br>支持重定向和重写。<br>Bitbucket Cloud<br>必须要通过 HTTPS 访问<br>不能自定义域名<br>所有项目的静态网站代码都只能放在专门的站点仓库里。<br>页面缓存 15 分钟，意味着改变不会立即可见。</p><h2 id="aerobatic"><a href="#aerobatic" class="headerlink" title="aerobatic"></a>aerobatic</h2><p>可以支持 CLI 上传代码<br>自定义域名需要收费。</p><h2 id="surge"><a href="#surge" class="headerlink" title="surge"></a>surge</h2><p>只支持 CLI<br>支持自定义域名，开启 SSL 是需要收费，同时需要自己上传证书</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>决定使用netlify 提供得部署，源代码依然在github上，netlify提供执行hexo相关命令环境，同时个人域名绑定都切换到netlify上, netlify 而且提供了免费https服务。</p><p>netlify 基于github 更新，github 对应的项目更新，netlify自动编译部署。这样免去了本地hexo环境。</p><p>个人测试速度还是有些差异：ping netlify 主机和gitpage 主机。</p><pre><code>部署在gitpage的站点$ ping mousemedia.ccPinging mousemedia.cc [185.199.109.153] with 32 bytes of data:Reply from 185.199.109.153: bytes=32 time=56ms TTL=52Reply from 185.199.109.153: bytes=32 time=57ms TTL=52Reply from 185.199.109.153: bytes=32 time=56ms TTL=52Reply from 185.199.109.153: bytes=32 time=57ms TTL=52Ping statistics for 185.199.109.153:    Packets: Sent = 4, Received = 4, Lost = 0 (0% loss),Approximate round trip times in milli-seconds:    Minimum = 56ms, Maximum = 57ms, Average = 56ms部署在netlify的站点$ ping mousemedia.cnPinging mousemedia.cn [178.128.17.49] with 32 bytes of data:Reply from 178.128.17.49: bytes=32 time=103ms TTL=53Reply from 178.128.17.49: bytes=32 time=103ms TTL=53Reply from 178.128.17.49: bytes=32 time=103ms TTL=53Reply from 178.128.17.49: bytes=32 time=103ms TTL=53Ping statistics for 178.128.17.49:    Packets: Sent = 4, Received = 4, Lost = 0 (0% loss),Approximate round trip times in milli-seconds:    Minimum = 103ms, Maximum = 103ms, Average = 103ms</code></pre><h1 id="具体部署过程"><a href="#具体部署过程" class="headerlink" title="具体部署过程"></a>具体部署过程</h1><p>之前github上已经备份了hexo 以及网址原文件：</p><img src="/2019/12/26/netlify-bu-shu-hexo-bo-ke-fang-fa-ji-lu/1.png" class=""><p>netlify 新建项目，并授权访问github hexo 项目（生产hexo静态页面的hexo源文件）<br>同时提供hexo 命令</p><p>设置好后，添加自己的域名。</p><p>同时修改域名服务器dns到netlify 提供的dns</p><img src="/2019/12/26/netlify-bu-shu-hexo-bo-ke-fang-fa-ji-lu/2.png" class=""><p>相关参考：</p><p><a href="Netlify搭建个人博客设置域名" title="https://blog.csdn.net/mqdxiaoxiao/article/details/96365253">Netlify搭建个人博客设置域名</a></p><h1 id="google-提交网址验证"><a href="#google-提交网址验证" class="headerlink" title="google 提交网址验证"></a>google 提交网址验证</h1><p>具体参考：<a href="https://www.woguide.com/archives/4933.html" target="_blank" rel="noopener">https://www.woguide.com/archives/4933.html</a></p>]]></content>
      
      
      <categories>
          
          <category> 建站技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> netlify </tag>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Markdown语法详解</title>
      <link href="/2019/12/24/markdown-yu-fa-xiang-jie/"/>
      <url>/2019/12/24/markdown-yu-fa-xiang-jie/</url>
      
        <content type="html"><![CDATA[<h1 id="常用快捷键"><a href="#常用快捷键" class="headerlink" title="常用快捷键"></a>常用快捷键</h1><ul><li>加粗 Ctrl + B</li><li>斜体 Ctrl + I</li><li>引用 Ctrl + Q</li><li>插入链接 Ctrl + L</li><li>插入代码 Ctrl + K</li><li>插入图片 Ctrl + G</li><li>提升标题 Ctrl + H</li><li>有序列表 Ctrl + O</li><li>无序列表 Ctrl + U</li><li>横线 Ctrl + R</li><li>撤销 Ctrl + Z</li><li>重做 Ctrl + Y</li></ul><h1 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h1><p>对字体设置斜体、粗体、删除线，语法如下：</p><img src="/2019/12/24/markdown-yu-fa-xiang-jie/1.jpg" class=""><h2 id="标题分级："><a href="#标题分级：" class="headerlink" title="标题分级："></a>标题分级：</h2><p><img src="2.jpeg" alt="标题分级"></p><h2 id="网址链接："><a href="#网址链接：" class="headerlink" title="网址链接："></a>网址链接：</h2><p><img src="3.jpeg" alt="网址链接"></p><h2 id="分割线"><a href="#分割线" class="headerlink" title="分割线"></a>分割线</h2><p>你可以在一行中用三个以上的星号(*)、减号(-)、底线(_)来建立一个分隔线，行内不能有其他东西。你也可以在星号或是减号中间插入空格。</p><p><img src="4.jpeg" alt="分割线"></p><h2 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h2><p>对于程序员来说这个功能是必不可少的，插入程序代码的方式有两种，一种是利用缩进(tab), 另一种是利用英文“`”符号（一般在ESC键下方，和~同一个键）包裹代码。</p><p>（1）代码块：缩进 4 个空格或是 1 个制表符。效果如下：</p><p><img src="5.jpeg" alt="代码块"></p><p>（2）行内式：如果在一个行内需要引用代码，只要用反引号`引起来就好(Esc健）</p><p><img src="6.jpeg" alt="行内式"></p><p>（3）多行代码块与语法高亮：在需要高亮的代码块的前一行及后一行使用三个单反引号“`”包裹，就可以了。</p><p>示例如下：<br><img src="7.jpeg" alt="多行代码"></p><p>（4）代码块里面包含html代码</p><p>在代码区块里面， &amp; 、 &lt; 和 &gt; 会自动转成 HTML 实体，这样的方式让你非常容易使用 Markdown 插入范例用的 HTML 原始码，只需要复制贴上，剩下的 Markdown 都会帮你处理。</p><p><img src="8.jpeg" alt="html语法表格"></p><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><p>在被引用的文本前加上&gt;符号，以及一个空格就可以了，如果只输入了一个&gt;符号会产生一个空白的引用。</p><p>（1）基本使用</p><p><img src="9.jpeg" alt="引用"></p><p>（2）引用的嵌套使用</p><p><img src="10.jpeg" alt="引用"></p><p>（3）引用其它要素</p><p><img src="11.jpeg" alt="引用"></p><h2 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h2><p>（1）无序列表</p><p>使用 *，+，- 表示无序列表。 注意：符号后面一定要有一个空格，起到缩进的作用。</p><p><img src="12.jpeg" alt="无序列表"></p><p>（2）有序列表</p><p>使用数字和一个英文句点表示有序列表。<br>注意：英文句点后面一定要有一个空格，起到缩进的作用。<br><img src="13.jpeg" alt="有序列表"></p><p>（3）无序列表和有序列表同时使用<br><img src="14.jpeg" alt=""></p><p>（4）列表和其它要素混合使用</p><p>列表不光可以单独使用，也可以使用其他的 Markdown 语法，包括标题、引用、代码区块等。</p><p><img src="15.jpeg" alt=""></p><blockquote><p>注意事项：<br>    - 加粗效果不能直接用于列表标题里面，但是可以嵌套在列表里面混合使用。<br>    - 列表中包含代码块（前面加2个tab或者8个空格，并且需要空一行，否则不显示）。</p></blockquote><p><img src="16.jpeg" alt=""></p><blockquote><p>注意事项：<br>在使用列表时，只要是数字后面加上英文的点，就会无意间产生列表，比如2017.12.30 这时候想表达的是日期，有些软件把它被误认为是列表。解决方式：在每个点前面加上\就可以了。如下图所示：</p></blockquote><p><img src="17.jpeg" alt=""></p><h2 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h2><p>表格的基本写法很简单，就跟表格的形状很相似：</p><p><img src="18.jpeg" alt=""></p><p>表格对齐方式：我们可以指定表格单元格的对齐方式，冒号在左边表示左对齐，右边表示有对齐，两边都有表示居中。<br><img src="19.jpeg" alt="表格对齐方式"></p><h1 id="常用技巧"><a href="#常用技巧" class="headerlink" title="常用技巧"></a>常用技巧</h1><h2 id="换行"><a href="#换行" class="headerlink" title="换行"></a>换行</h2><p>方法1: 连续两个以上空格+回车<br>方法2：使用html语言换行标签：&lt;br&gt;</p><h2 id="缩进字符"><a href="#缩进字符" class="headerlink" title="缩进字符"></a>缩进字符</h2><p>不断行的空白格 &amp;\nbsp; 或 &amp;#160;半角的空格 &amp;ensp; 或 &amp;#8194;全角的空格 &amp;emsp; 或 &amp;#8195;<br><img src="20.jpeg" alt="markdown缩进"></p><h2 id="如何显示特殊符号"><a href="#如何显示特殊符号" class="headerlink" title="如何显示特殊符号"></a>如何显示特殊符号</h2><p>对于 Markdown 中的语法符号，前面加反斜线\即可显示符号本身。<br><img src="21.jpeg" alt="markdown特殊符号"></p><p>其他特殊字符：<br><img src="22.jpeg" alt="markdown特殊符号"></p><h2 id="字体、字号与颜色"><a href="#字体、字号与颜色" class="headerlink" title="字体、字号与颜色"></a>字体、字号与颜色</h2><p><img src="23.jpeg" alt="markdown字体字号颜色"><br>具体颜色分类及标记请看下表：<br><img src="24.jpeg" alt="markdown字体字号颜色"></p><h2 id="图片位置"><a href="#图片位置" class="headerlink" title="图片位置"></a>图片位置</h2><p><code>&lt;div align=right&gt;![这里写图片描述](http:...)</code><br><code>&lt;div align=center&gt;![这里写图片描述](http:...)</code></p><h1 id="高级技巧"><a href="#高级技巧" class="headerlink" title="高级技巧"></a>高级技巧</h1><h2 id="锚点"><a href="#锚点" class="headerlink" title="锚点"></a>锚点</h2><p>锚点其实就是页内超链接。比如我这里写下一个锚点，点击回到目录，就能跳转到目录。 在目录中点击这一节，就能跳过来。</p><p><img src="25.jpeg" alt="锚点"></p><h2 id="注脚"><a href="#注脚" class="headerlink" title="注脚"></a>注脚</h2><p>语法说明：<br>在需要添加注脚的文字后加上脚注名字[^注脚名字],称为加注。 然后在文本的任意位置(一般在最后)添加脚注，脚注前必须有对应的脚注名字。<br><img src="26.jpeg" alt="注脚"></p><blockquote><p>注：<br>（1）脚注自动被搬运到最后面，请到文章末尾查看，并且脚注后方的链接可以直接跳转回到加注的地方。<br>（2）由于简书不支持锚点，所以可以用注脚实现页面内部的跳转。</p></blockquote><h2 id="背景色"><a href="#背景色" class="headerlink" title="背景色"></a>背景色</h2><p>Markdown本身不支持背景色设置，需要采用内置html的方式实现：借助 table, tr, td 等表格标签的 bgcolor 属性来实现背景色的功能。举例如下：<br><img src="27.png" alt="背景色"></p><h2 id="emoji表情符号"><a href="#emoji表情符号" class="headerlink" title="emoji表情符号"></a>emoji表情符号</h2><p>emoji表情使用:EMOJICODE:的格式，详细列表可见:<br><a href="https://www.webfx.com/tools/emoji-cheat-sheet/" target="_blank" rel="noopener">https://www.webfx.com/tools/emoji-cheat-sheet/</a><br>很多markdown工具或者网站都不支持.<br><img src="27.jpeg" alt="emoji表情符号"></p><h1 id="公式"><a href="#公式" class="headerlink" title="公式"></a>公式</h1><p><img src="28.png" alt="公式"></p><h2 id="LaTex是什么？"><a href="#LaTex是什么？" class="headerlink" title="LaTex是什么？"></a>LaTex是什么？</h2><p>LaTeX（LATEX，音译“拉泰赫”）是一种基于ΤΕΧ的排版系统，由美国计算机学家莱斯利·兰伯特（Leslie Lamport）在20世纪80年代初期开发，利用这种格式，即使使用者没有排版和程序设计的知识也可以充分发挥由TeX所提供的强大功能，能在几天，甚至几小时内生成很多具有书籍质量的印刷品。对于生成复杂表格和数学公式，这一点表现得尤为突出。因此它非常适用于生成高印刷质量的科技和数学类文档。这个系统同样适用于生成从简单的信件到完整书籍的所有其他种类的文档。</p><h2 id="简单的规则"><a href="#简单的规则" class="headerlink" title="简单的规则"></a>简单的规则</h2><p><img src="29.png" alt="公式"></p><h2 id="常用数学符号的-LaTeX-表示方法"><a href="#常用数学符号的-LaTeX-表示方法" class="headerlink" title="常用数学符号的 LaTeX 表示方法"></a>常用数学符号的 LaTeX 表示方法</h2><p><img src="30.png" alt="公式"><br><img src="31.png" alt="公式"><br><img src="32.png" alt="公式"></p><hr><h1 id="流程图"><a href="#流程图" class="headerlink" title="流程图"></a>流程图</h1><p><img src="28.jpeg" alt="流程图"><br>制作一份待办事宜—-Todo 列表<br><img src="29.jpeg" alt="流程图"><br>序列图：<br><img src="30.jpeg" alt="序列图"><br>甘特图：<br><img src="31.jpeg" alt="甘特图"></p><p>本文参考文章：<br><a href="https://mp.weixin.qq.com/s?__biz=MzIwMzYwMTk1NA==&amp;mid=2247489234&amp;idx=1&amp;sn=c6de4582a1400af22e0908f05a8870bc" target="_blank" rel="noopener">https://mp.weixin.qq.com/s?__biz=MzIwMzYwMTk1NA==&amp;mid=2247489234&amp;idx=1&amp;sn=c6de4582a1400af22e0908f05a8870bc</a></p>]]></content>
      
      
      <categories>
          
          <category> 建站技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo gitpage 博客本地文件备份恢复</title>
      <link href="/2019/12/24/hexo-gitpage-bo-ke-ben-di-wen-jian-bei-fen-hui-fu/"/>
      <url>/2019/12/24/hexo-gitpage-bo-ke-ben-di-wen-jian-bei-fen-hui-fu/</url>
      
        <content type="html"><![CDATA[<h1 id="Hexo-源文件备份说明"><a href="#Hexo-源文件备份说明" class="headerlink" title="Hexo 源文件备份说明"></a>Hexo 源文件备份说明</h1><ul><li>_config.yml站点的配置文件，<strong>需要拷贝</strong></li><li>themes/主题文件夹，<strong>需要拷贝</strong>；</li><li>source博客文章的.md文件，<strong>需要拷贝</strong>；</li><li>scaffolds/文章的模板，<strong>需要拷贝</strong>；</li><li>package.json安装包的名称，<strong>需要拷贝</strong>；</li><li>.gitignore限定在push时哪些文件可以忽略，<strong>需要拷贝</strong>；</li><li>.git/主题和站点都有，标志这是一个git项目，不需要拷贝；</li><li>node_modules/是安装包的目录，在执行npm install的时候会重新生成，不需要拷贝；</li><li>public是hexo g生成的静态网页，不需要拷贝；</li><li>.deploy_git同上，hexo g也会生成，不需要拷贝；</li><li>db.json文件，不需要拷贝。</li></ul><h1 id="github-保存需要备份的hexo文件"><a href="#github-保存需要备份的hexo文件" class="headerlink" title="github 保存需要备份的hexo文件"></a>github 保存需要备份的hexo文件</h1><p>两种方法： </p><ul><li>直接新建一个repro， git上传上面的文件。</li><li>在网站项目xxx.github.io 上新建一个分支（branch 名字可以选择hexo， 原来master分支不变，继续保存静态网页，把需要备份的源文件资源上传到hexo分支。）</li></ul><h1 id="hexo环境恢复（如更换电脑）"><a href="#hexo环境恢复（如更换电脑）" class="headerlink" title="hexo环境恢复（如更换电脑）"></a>hexo环境恢复（如更换电脑）</h1><ul><li>安装git；</li><li>安装Nodejs和npm；</li><li>使用克隆命令将仓库拷贝至本地；</li><li>在文件夹内执行命令<pre><code>  npm install hexo-cli -g  npm install  npm install hexo-deployer-git</code></pre></li></ul><p>备份文件修改后，备份改动上传：执行git add，git commit -m “提交文件”，git push origin Hexo来提交Hexo网站源文件；</p>]]></content>
      
      
      <categories>
          
          <category> 建站技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>FFmpeg 常用命令汇总</title>
      <link href="/2019/12/23/ffmpeg-chang-yong-ming-ling-hui-zong/"/>
      <url>/2019/12/23/ffmpeg-chang-yong-ming-ling-hui-zong/</url>
      
        <content type="html"><![CDATA[<h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>开源音视频处理工具FFMPEG以其强大的功能而在音视频领域著称，从音视频格式转换、裁剪、拼接、提取字幕到提取视频流，编解码等无所不能，本页汇集整理FFmpeg常用命令。</p><h1 id="常用命令示例"><a href="#常用命令示例" class="headerlink" title="常用命令示例"></a>常用命令示例</h1><pre><code>ffmpeg -h   // 帮助ffmpeg -version // 版本信息ffmepg -devices // 查看可用设备ffmpeg -i input.mp4 // 查看视频信息</code></pre><h1 id="ffmpeg-命令行参数解析"><a href="#ffmpeg-命令行参数解析" class="headerlink" title="ffmpeg 命令行参数解析"></a>ffmpeg 命令行参数解析</h1><pre><code>00:00:46.61 视频时长3949kb/s 码率h264:视频编码格式avc1:苹果公司开发的复合h264规范的格式yuv420p:视频颜色编码方式960x400:分辨率SAR 1:1 :图像采集时，采集的宽高点阵的点数比值DAR:图像宽高比PAR:像素的长宽比23.98 fps: 帧率23.98 tbr: 帧率24k tbn: 文件层的时间精度1S=24k,一秒增加24k47.95 tbc:视频层的时间精度1S=47.95,一秒增加47.95aac:音频编码格式mp4a:stereo:立体声fltp:音频帧格式</code></pre><h1 id="常用命令示例-1"><a href="#常用命令示例-1" class="headerlink" title="常用命令示例"></a>常用命令示例</h1><h2 id="添加字幕"><a href="#添加字幕" class="headerlink" title="添加字幕"></a>添加字幕</h2><pre><code>ffmpeg -i input.mp4 -vf subtitles=text.srt output.mp4</code></pre><h2 id="视频剪切"><a href="#视频剪切" class="headerlink" title="视频剪切"></a>视频剪切</h2><pre><code>ffmpeg -ss 00:00:15 -t 00:00:05 -i input.mp4 -vcodec copy -acodec copy output.mp4// -ss表示开始切割的时间，-t表示要切多少。上面就是从15秒开始，切5秒钟出来</code></pre><h2 id="码率控制"><a href="#码率控制" class="headerlink" title="码率控制"></a>码率控制</h2><pre><code>ffmpeg -i input.mp4 -b:v 2000k output.mp4ffmpeg -i input.mp4 -b:v 2000k -bufsize 2000 output.mp4 // -bufsize 缓冲区ffmpeg -i input.mp4 -b:v 2000k -bufsize 2000k -maxrate 2500k -minrate 1500k output.mp4 // 最大最小域值</code></pre><h2 id="提取视频流"><a href="#提取视频流" class="headerlink" title="提取视频流"></a>提取视频流</h2><pre><code>ffmpeg -i input.mp4 -vcodec copy -an -f m4v output.h264</code></pre><h2 id="保存视频宽高"><a href="#保存视频宽高" class="headerlink" title="保存视频宽高"></a>保存视频宽高</h2><pre><code>ffmpeg -i input.mp4 -vf scale=960:540 output.mp4ffmpeg -i input.mp4 -vf scale=960:-1 output.mp4 // 保持宽高比,注意宽要能被2出尽，不然报错</code></pre><h2 id="添加水印"><a href="#添加水印" class="headerlink" title="添加水印"></a>添加水印</h2><pre><code>ffmpeg -i input.mp4 -i logo.png -filter_complex overlay output.mp4ffmpeg -i input.mp4 -i logo.png -filter_complex overlay=W-w output.mp4 // 右上角ffmpeg -i input.mp4 -i logo.png -filter_complex overlay=0:H-h output.mp4 // 左下角ffmpeg -i input.mp4 -i logo.png -filter_complex overlay=W-w:H-h output.mp4 // 右下角</code></pre><h2 id="去除水印"><a href="#去除水印" class="headerlink" title="去除水印"></a>去除水印</h2><pre><code>ffmpeg -i input.mp4 -vf delogo=1:1:144:144:1 output.mp4 // -vf delogo=x:y:w:h[:show], x:y离左上角坐标,设0报错，w:h logo宽高，show设置一个绿色的矩形，默认0</code></pre><h2 id="截取视频图像"><a href="#截取视频图像" class="headerlink" title="截取视频图像"></a>截取视频图像</h2><pre><code>ffmpeg -i input.mp4 -r 1 -q:v 2 -f image2 pic-%03d.jpeg // -r 每一秒几帧，-q:v 存储jpeg的图像质量，一般2是高质量ffmpeg -i input.mp4 -ss 00:00:20 -t 10 -r 1 -q:v 2 -f image2 pic-%03d.jpeg //抽取10帧图片随便挑一张，转为YUV:ffmpeg -i pic-001.jpeg -s 1440x1440 -pix_fmt yuv420p xxx3.yuv</code></pre><h2 id="图片序列与视频转换"><a href="#图片序列与视频转换" class="headerlink" title="图片序列与视频转换"></a>图片序列与视频转换</h2><pre><code>ffmpeg -i 001.mp3 -i example.%d.jpg -s 1024x768 -vcodec mpeg4 rebuild.mp4 // 把图片序列帧和音频文件利用mpeg4编码方式合成视频文件darkdoor.aviffmpeg -i input.mp4 example.%d.jpg // 把视频文件导出成序列帧</code></pre><h2 id="ffmpeg-控制视频profile"><a href="#ffmpeg-控制视频profile" class="headerlink" title="ffmpeg 控制视频profile"></a>ffmpeg 控制视频profile</h2><pre><code>ffmpeg -i input.mp4 -profile:v baseline -level 3.0 output.mp4    ffmpeg -i input.mp4 -profile:v main -level 4.2 output.mp4    ffmpeg -i input.mp4 -profile:v high -level 5.1 output.mp4如果ffmpeg编译时加了external的libx264，可以这样写：ffmpeg -i input.mp4 -c:v libx264 -x264-params &quot;profile=high:level=3.0&quot; output.mp4从压缩比例来说，baseline&lt; main &lt; high，对于带宽比较局限的在线视频，可能会选择high，但有些时候，做个小视频，希望所有的设备基本都能解码（有些低端设备或早期的设备只能解码baseline），那就牺牲文件大小吧，用baseline。自己取舍吧！</code></pre><h2 id="解码H-264-H-265码流（解码）"><a href="#解码H-264-H-265码流（解码）" class="headerlink" title="解码H.264/H.265码流（解码）"></a>解码H.264/H.265码流（解码）</h2><pre><code>ffmpeg -i input_file.264 -vframes 100 output.yuvffmpeg -i input_file.265 -vframes 100 output.yuv</code></pre><h2 id="转换成H264码流（编码）"><a href="#转换成H264码流（编码）" class="headerlink" title="转换成H264码流（编码）"></a>转换成H264码流（编码）</h2><pre><code>ffmpeg -i input_file.yuv -vcodec h264 output_file.264 其中 -i 表示输入文件， -vcodec h264 表示视频编解码方式为 H264。</code></pre><h2 id="编码质量"><a href="#编码质量" class="headerlink" title="编码质量"></a>编码质量</h2><pre><code>ffmpeg -i input -c:v libx264 -profile:v main -preset:v fast -level 3.1 -x264opts crf=18    编码效率和视频质量的取舍:强行配置biterate，或者强行配置profile/level，还有2个参数可以控制编码效率。一个是preset，一个是crf。preset也挺粗暴，基本原则就是，如果你觉得编码太快或太慢了，想改改，可以用profile。preset有如下参数可用：ultrafast, superfast, veryfast, faster, fast, medium, slow, slower, veryslow and placebo.编码加快，意味着信息丢失越严重，输出图像质量越差。 CRF(Constant Rate Factor): 范围 0-51: 0是编码毫无丢失信息, 23 is 默认, 51 是最差的情况。相对合理的区间是18-28.值越大，压缩效率越高，但也意味着信息丢失越严重，输出图像质量越差</code></pre><h2 id="转换成H265码流（编码）"><a href="#转换成H265码流（编码）" class="headerlink" title="转换成H265码流（编码）"></a>转换成H265码流（编码）</h2><pre><code>ffmpeg -i input_file -vcode hevc output_file  其中 -i 表示输入文件， -vcodec hevc 表示视频编解码方式为 H265，注意ffmpeg 中名称为 hevc，不是H265！</code></pre><h2 id="设置输出视频的分辨率"><a href="#设置输出视频的分辨率" class="headerlink" title="设置输出视频的分辨率"></a>设置输出视频的分辨率</h2><pre><code>ffmpeg -i input_file -vcodec h264 -s 1280x720 output_file其中 -s 表示分辨率。</code></pre><h2 id="设置输出文件的音视频比特率"><a href="#设置输出文件的音视频比特率" class="headerlink" title="设置输出文件的音视频比特率"></a>设置输出文件的音视频比特率</h2><pre><code>ffmpeg -i input_file  -vcodec h264 -b:v 10M -b:a 128K output_file其中 -b:v 10M 表示视频码率为10Mbps， -b:a 128K 表示音频码率为 128Kbps，注意FFMPEG对于码率控制，有时候不太准确，跟输入源有一定关系。</code></pre><h2 id="剪切某段视频"><a href="#剪切某段视频" class="headerlink" title="剪切某段视频"></a>剪切某段视频</h2><pre><code>ffmpeg -ss 0:05:00 -t 0:1:30 -i input_file -vcodec copy -acodec copy output_file  ffmpeg -ss 300 -t 90  -i input_file -vcodec copy -acodec copy output_file上面的两种方式等价，时间格式支持 HH:MM:SS或者秒数。 -ss 开始时间， -t 持续时间， -vcodec copy 保持原视频编码方式， -acodec copy 保持原音频编码方式。注意：-vcodec copy与-c:v以及-codec:v 这三种写法的功能是一样的，具体可参考：[https://lists.ffmpeg.org/pipermail/ffmpeg-user/2017-February/035335.html](https://lists.ffmpeg.org/pipermail/ffmpeg-user/2017-February/035335.html &quot;https://lists.ffmpeg.org/pipermail/ffmpeg-user/2017-February/035335.html&quot;)</code></pre><h2 id="分离音视频流保存为不同文件"><a href="#分离音视频流保存为不同文件" class="headerlink" title="分离音视频流保存为不同文件"></a>分离音视频流保存为不同文件</h2><pre><code>ffmpeg -i input_file -vcodec copy -an output_file_video　　//提取视频流 ffmpeg -i input_file -acodec copy -vn output_file_audio　　//提取音频流其中 -an 表示不处理音频， -vn 表示不处理视频。</code></pre><h2 id="合并多个音视频文件为一个文件"><a href="#合并多个音视频文件为一个文件" class="headerlink" title="合并多个音视频文件为一个文件"></a>合并多个音视频文件为一个文件</h2><pre><code>ffmpeg –i video_file –i audio_file –vcodec copy –acodec copy output_file </code></pre><h2 id="提取视频图像保存为图片文件-将视频分解为单幅图片"><a href="#提取视频图像保存为图片文件-将视频分解为单幅图片" class="headerlink" title="提取视频图像保存为图片文件(将视频分解为单幅图片)"></a>提取视频图像保存为图片文件(将视频分解为单幅图片)</h2><pre><code>ffmpeg –i input_file –r 1 –f image2 image-%3d.jpeg        //提取图片其中 -r 表示提取图像的频率，-f 表示输出格式， %3d 表示文件命名方式（也即生成的图片名为 image-001.jpeg, image-002.jpeg, …, image-999.jpeg）。</code></pre><h2 id="转换成YUV原始文件"><a href="#转换成YUV原始文件" class="headerlink" title="转换成YUV原始文件"></a>转换成YUV原始文件</h2><pre><code>ffmpeg -i input_file -vcodec rawvideo -an output_file_yuv</code></pre><h2 id="YUV序列转出AVI文件"><a href="#YUV序列转出AVI文件" class="headerlink" title="YUV序列转出AVI文件"></a>YUV序列转出AVI文件</h2><pre><code>ffmpeg –s w*h –pix_fmt yuv420p –i input.yuv –vcodec mpeg4 output.avi </code></pre><h2 id="控制关键帧间隔和B帧"><a href="#控制关键帧间隔和B帧" class="headerlink" title="控制关键帧间隔和B帧"></a>控制关键帧间隔和B帧</h2><pre><code>ffmpeg –i input_file  –vcodec h264 –bf 0 –g 25 –s 854x480 –an –f m4v output_file其中-bf 控制B帧数目，-g 控制关键帧间隔， -f 控制文件格式（format，注意与codec的区别）。</code></pre><h2 id="多个视频文件拼接"><a href="#多个视频文件拼接" class="headerlink" title="多个视频文件拼接"></a>多个视频文件拼接</h2><pre><code>首先创建一个需要拼接的文件，例如 concat.txt，内容如下：file ‘orig_20160616113303_0.avi’file ‘orig_20160616113303_1.avi’然后执行如下命令ffmpeg  -f concat -i concat.txt  -c copy orig_20160616113303_merge.avi </code></pre><h2 id="YUV处理相关命令（持续更新ing）"><a href="#YUV处理相关命令（持续更新ing）" class="headerlink" title="YUV处理相关命令（持续更新ing）"></a>YUV处理相关命令（持续更新ing）</h2><pre><code>查看ffmpeg支持哪些yuv格式的转换ffmpeg -pix_fmts  </code></pre><h2 id="ffmpeg转换yuv格式命令"><a href="#ffmpeg转换yuv格式命令" class="headerlink" title="ffmpeg转换yuv格式命令"></a>ffmpeg转换yuv格式命令</h2><pre><code>ffmpeg -pix_fmt yuv420p -s 176x144 -i carphone_qcif.yuv -pix_fmt nv12 carphone_qcif_nv12.yuv  </code></pre><h2 id="ffmpeg命令行yuv缩放命令"><a href="#ffmpeg命令行yuv缩放命令" class="headerlink" title="ffmpeg命令行yuv缩放命令"></a>ffmpeg命令行yuv缩放命令</h2><pre><code>ffmpeg -s:v 1920x1080 -r 25 -i input.yuv -vf scale=960:540 -c:v rawvideo -pix_fmt yuv420p out.yuv  </code></pre><h2 id="ffmpeg解码码流命令"><a href="#ffmpeg解码码流命令" class="headerlink" title="ffmpeg解码码流命令"></a>ffmpeg解码码流命令</h2><pre><code>ffmpeg -i 720P.264 -s 1280x720 -pix_fmt yuv422p 720P-out.yuv  ffmpeg -i 720P.264 -vframes 300  720P-out.yuv    //指定解码的帧数简化版：ffmpeg -i 720P.264 720P-out.yuv注意不同选项的顺序，-s选项放在-i后面，指定不同分辨率时，在解码后进行了缩放。</code></pre><h2 id="ffmpeg-yuv转avi"><a href="#ffmpeg-yuv转avi" class="headerlink" title="ffmpeg yuv转avi"></a>ffmpeg yuv转avi</h2><pre><code>ffmpeg -s wxh -pix_fmt yuv420p -i input.yuv -vcodec mpeg4 output.avi  ffmpeg -s wxh -pix_fmt yuv420p -i input.yuv -vcodec h264 output.avi  </code></pre><h2 id="ffmpeg-裸码流转avi"><a href="#ffmpeg-裸码流转avi" class="headerlink" title="ffmpeg 裸码流转avi"></a>ffmpeg 裸码流转avi</h2><pre><code>ffmpeg -f h264 -i source.264 -c:v libx264 -an dest.aviUse -c:v copy instead to copy the source stream without re-encoding</code></pre><h2 id="ffmpeg-avi转裸码流"><a href="#ffmpeg-avi转裸码流" class="headerlink" title="ffmpeg avi转裸码流"></a>ffmpeg avi转裸码流</h2><pre><code>提取裸码流ffmpeg.exe -i BQSquare_416x240_37.avi -f rawvideo -vcodec copy xx.264提取若干帧数码流ffmpeg.exe -i BQSquare_416x240_37.avi -f rawvideo -vcodec copy -vframes 100 xx.264对于提取特定的帧，需要用特殊的方法：假设提取260帧，帧率是26， 则可用-ss 10.0 其中10.0=260/26</code></pre><h2 id="YUV裁剪功能"><a href="#YUV裁剪功能" class="headerlink" title="YUV裁剪功能"></a>YUV裁剪功能</h2><pre><code>Extract some YUV frames from large yuv File从第0帧开始截取30帧：ffmpeg -s widthxheight -i input.yuv -c:v rawvideo -filter:v &quot;select=&#39;gt(n\, -1)&#39;&quot; -vframes 30 out30.yuv或者：ffmpeg -s widthxheight -i input.yuv -c:v rawvideo -filter:v &quot;select=&#39;between(n\, 0\, 29)&#39;&quot; out30.yuv或者：ffmpeg -r 1 -ss 0 -i input.yuv -vcodec copy -vframes 30 output.yuv中间截取帧（截取从第30帧到第100帧）：ffmpeg -s widthxheight -i input.yuv -c:v rawvideo -filter:v &quot;select=&#39;between(n\, 30\, 100)&#39;&quot; out.yuv根据时间截取帧（截取从第10秒到第20秒 ）：//Select only frames contained in the 10-20 time interval://select=between(t\,10\,20)ffmpeg -s widthxheight -i input.yuv -c:v rawvideo -filter:v &quot;select=&#39;between(t\, 10\, 20)&#39;&quot; out.yuv参考自： [https://blog.csdn.net/listener51/article/details/82025541](https://blog.csdn.net/listener51/article/details/82025541 &quot;https://blog.csdn.net/listener51/article/details/82025541&quot;)</code></pre><h2 id="提取YUV数据"><a href="#提取YUV数据" class="headerlink" title="提取YUV数据"></a>提取YUV数据</h2><pre><code>ffmpeg.exe -ss 00:02:45 -t 00:00:18  -i 8k.mp4 -an -c:v rawvideo -pix_fmt yuv420p 8k.yuvffmpeg -i killer.mp4 -an -c:v rawvideo -pix_fmt yuv420p ouy.yuv参数说明-c:v rawvideo 指定将视频转成原始数据-pixel_format yuv420p 指定转换格式为yuv420p</code></pre><img src="/2019/12/23/ffmpeg-chang-yong-ming-ling-hui-zong/1.jpeg" class=""><p>从日志中可以看出，像素格式:yuv420p,分辨率:608x368，使用ffplay播放一下。需要指定分辨率，这个时候不需要指定视频格式了，ffplay默认像素格式格式就是yuv420p。</p><pre><code>ffplay -s 608x368 ouy.yuv</code></pre><h2 id="提取PCM数据"><a href="#提取PCM数据" class="headerlink" title="提取PCM数据"></a>提取PCM数据</h2><pre><code>ffmpeg -i killer.mp4 -vn -ar 44100 -ac 2 -f s16le out.pcm参数说明：-ar:指定音频采样率 44100 即44.1KHz-ac:指定音频声道channel 2 为双声道-f：数据存储格式 s：Signed 有符号的， 16： 每一个数值用16位表示， l： little， e： end使用ffplay播放ffplay -ar 44100 -ac 2 -f s16le out.pcm</code></pre><h1 id="FFMPEG常用参数说明"><a href="#FFMPEG常用参数说明" class="headerlink" title="FFMPEG常用参数说明"></a>FFMPEG常用参数说明</h1><pre><code>主要参数：-i 设定输入流-f 设定输出格式-ss 开始时间-formats 查看所有支持的容器格式-codecs 查看所有编解码器-filters 查看所有可用的filter-pix_fmts 查看所有支持的图片格式-sample_fmts 查看所有支持的像素格式-i input_file 查看媒体文件input_file的信息（注意后面不再接其它参数，例如: ffmpeg -i test.mp4，查看 test.mp4视频信息）视频参数：-b 设定视频流量，默认为200Kbit/s-r 设定帧速率，默认为25-s 设定画面的宽与高-aspect 设定画面的比例-vn 不处理视频-vcodec 设定视频编解码器，未设定时则使用与输入流相同的编解码器音频参数：-ar 设定采样率-ac 设定声音的Channel数-acodec 设定声音编解码器，未设定时则使用与输入流相同的编解码器-an 不处理音频</code></pre><h1 id="ffmpeg-帮助"><a href="#ffmpeg-帮助" class="headerlink" title="ffmpeg 帮助"></a>ffmpeg 帮助</h1><pre><code>    Getting help: 帮助        -h      -- print basic options        -h long -- print more options        -h full -- print all options (including all format and codec specific options, very long)        -h type=name -- print all options for the named decoder/encoder/demuxer/muxer/filter/bsf        See man ffmpeg for detailed description of the options.    Print help / information / capabilities:    -L                  show license     -h topic            show help    -? topic            show help    -help topic         show help    --help topic        show help    -version            show version    -buildconf          show build configuration    -formats            show available formats    -muxers             show available muxers    -demuxers           show available demuxers    -devices            show available devices    -codecs             show available codecs    -decoders           show available decoders    -encoders           show available encoders    -bsfs               show available bit stream filters    -protocols          show available protocols    -filters            show available filters    -pix_fmts           show available pixel formats    -layouts            show standard channel layouts    -sample_fmts        show available audio sample formats    -colors             show available color names    -sources device     list sources of the input device    -sinks device       list sinks of the output device    -hwaccels           show available HW acceleration methods    Global options (affect whole program instead of just one file:    -loglevel loglevel  set logging level    -v loglevel         set logging level    -report             generate a report    -max_alloc bytes    set maximum size of a single allocated block    -y                  overwrite output files    -n                  never overwrite output files    -ignore_unknown     Ignore unknown stream types    -filter_threads     number of non-complex filter threads    -filter_complex_threads  number of threads for -filter_complex    -stats              print progress report during encoding    -max_error_rate maximum error rate  ratio of errors (0.0: no errors, 1.0: 100% errors) above which ffmpeg returns an error instead of success.    -bits_per_raw_sample number  set the number of bits per raw sample    -vol volume         change audio volume (256=normal)    Per-file main options:    -f fmt              force format    -c codec            codec name    -codec codec        codec name    -pre preset         preset name    -map_metadata outfile[,metadata]:infile[,metadata]  set metadata information of outfile from infile    -t duration         record or transcode &quot;duration&quot; seconds of audio/video    -to time_stop       record or transcode stop time    -fs limit_size      set the limit file size in bytes    -ss time_off        set the start time offset    -sseof time_off     set the start time offset relative to EOF    -seek_timestamp     enable/disable seeking by timestamp with -ss    -timestamp time     set the recording timestamp (&#39;now&#39; to set the current time)    -metadata string=string  add metadata    -program title=string:st=number...  add program with specified streams    -target type        specify target file type (&quot;vcd&quot;, &quot;svcd&quot;, &quot;dvd&quot;, &quot;dv&quot; or &quot;dv50&quot; with optional prefixes &quot;pal-&quot;, &quot;ntsc-&quot; or &quot;film-&quot;)    -apad               audio pad    -frames number      set the number of frames to output    -filter filter_graph  set stream filtergraph    -filter_script filename  read stream filtergraph description from a file    -reinit_filter      reinit filtergraph on input parameter changes    -discard            discard    -disposition        disposition    Video options:    -vframes number     set the number of video frames to output    -r rate             set frame rate (Hz value, fraction or abbreviation)    -s size             set frame size (WxH or abbreviation)    -aspect aspect      set aspect ratio (4:3, 16:9 or 1.3333, 1.7777)    -bits_per_raw_sample number  set the number of bits per raw sample    -vn                 disable video    -vcodec codec       force video codec (&#39;copy&#39; to copy stream)    -timecode hh:mm:ss[:;.]ff  set initial TimeCode value.    -pass n             select the pass number (1 to 3)    -vf filter_graph    set video filters    -ab bitrate         audio bitrate (please use -b:a)    -b bitrate          video bitrate (please use -b:v)    -dn                 disable data    Audio options:    -aframes number     set the number of audio frames to output    -aq quality         set audio quality (codec-specific)    -ar rate            set audio sampling rate (in Hz)    -ac channels        set number of audio channels    -an                 disable audio    -acodec codec       force audio codec (&#39;copy&#39; to copy stream)    -vol volume         change audio volume (256=normal)    -af filter_graph    set audio filters    Subtitle options:    -s size             set frame size (WxH or abbreviation)    -sn                 disable subtitle    -scodec codec       force subtitle codec (&#39;copy&#39; to copy stream)    -stag fourcc/tag    force subtitle tag/fourcc    -fix_sub_duration   fix subtitles duration    -canvas_size size   set canvas size (WxH or abbreviation)    -spre preset        set the subtitle options to the indicated preset</code></pre><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>  ffmpeg功能强大，参数配置众多，最好的方式查看它的命令行帮助文档，各个参数都有详细的说明，唯一的遗憾就是没有例子，对于初入媒体领域的人来说，门槛比较高。不明白的参数，可以多试试，再接合MediaInfo工具查看具体信息，通过VLC或者FFMPEG自带的 ffplay播放器播放，就容易理解了。</p><h1 id="文档参考"><a href="#文档参考" class="headerlink" title="文档参考"></a>文档参考</h1><p><a href="https://blog.csdn.net/tj297202234/article/details/90484154" target="_blank" rel="noopener">https://blog.csdn.net/tj297202234/article/details/90484154</a></p><p>官网翻译文档：<a href="https://www.bookstack.cn/read/other-doc-cn-ffmpeg/ffmpeg-doc-cn-40.md" target="_blank" rel="noopener">https://www.bookstack.cn/read/other-doc-cn-ffmpeg/ffmpeg-doc-cn-40.md</a></p><p>官方ffmpeg命令行参考文档：<a href="http://ffmpeg.org/ffmpeg.html" target="_blank" rel="noopener">http://ffmpeg.org/ffmpeg.html</a><br>参考网址：<a href="https://stackoverflow.com/questions/33108985/ffmpeg-264-to-avi" target="_blank" rel="noopener" title="https://stackoverflow.com/questions/33108985/ffmpeg-264-to-avi">https://stackoverflow.com/questions/33108985/ffmpeg-264-to-avi</a></p><p>更多ffmpeg命令使用可参考：<br><a href="http://processors.wiki.ti.com/index.php/Open_Source_Video_Processing_Tools_-_MPlayer,_FFMpeg,_AviSynth,_MKVToolnix,_MP4Box#Downloads" target="_blank" rel="noopener">http://processors.wiki.ti.com/index.php/Open_Source_Video_Processing_Tools_-_MPlayer,_FFMpeg,_AviSynth,_MKVToolnix,_MP4Box#Downloads</a><br><a href="http://ffmpeg.org/ffmpeg-filters.html#aselect_002c-select" target="_blank" rel="noopener">http://ffmpeg.org/ffmpeg-filters.html#aselect_002c-select</a><br><a href="https://lists.ffmpeg.org/pipermail/ffmpeg-user/2017-February/035335.html" target="_blank" rel="noopener">https://lists.ffmpeg.org/pipermail/ffmpeg-user/2017-February/035335.html</a><br><a href="https://www.bookstack.cn/read/other-doc-cn-ffmpeg/ffmpeg-doc-cn-40.md" target="_blank" rel="noopener">https://www.bookstack.cn/read/other-doc-cn-ffmpeg/ffmpeg-doc-cn-40.md</a><br><a href="https://blog.csdn.net/SoaringLee_fighting/article/details/56015567" target="_blank" rel="noopener">https://blog.csdn.net/SoaringLee_fighting/article/details/56015567</a><br><a href="https://www.suninf.net/2017/02/ffmpeg-command-usage.html" target="_blank" rel="noopener">https://www.suninf.net/2017/02/ffmpeg-command-usage.html</a><br><a href="https://blog.csdn.net/soaringlee_fighting/article/details/80571673" target="_blank" rel="noopener">https://blog.csdn.net/soaringlee_fighting/article/details/80571673</a></p>]]></content>
      
      
      <categories>
          
          <category> 影音技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> FFmpeg </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>视频基础系列课程17 总结</title>
      <link href="/2019/12/19/shi-pin-ji-chu-xi-lie-ke-cheng-17-zong-jie/"/>
      <url>/2019/12/19/shi-pin-ji-chu-xi-lie-ke-cheng-17-zong-jie/</url>
      
        <content type="html"><![CDATA[<h1 id="conclusion"><a href="#conclusion" class="headerlink" title="conclusion"></a>conclusion</h1><p>视频基础系列课程：总结</p><div style="position: relative; width: 100%; height: 0; padding-bottom: 75%;"><iframe src="//player.bilibili.com/player.html?aid=25917381&cid=44337924&page=17" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true" style="position: absolute; width:100%; height:100%;left:0;top:0;"></iframe></div>]]></content>
      
      
      <categories>
          
          <category> 影音技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 视频基础 </tag>
            
            <tag> 视频公开课 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>视频基础系列课程16 如何减小视频文件输出大小</title>
      <link href="/2019/12/19/shi-pin-ji-chu-xi-lie-ke-cheng-16-ru-he-jian-xiao-shi-pin-shu-chu-da-xiao/"/>
      <url>/2019/12/19/shi-pin-ji-chu-xi-lie-ke-cheng-16-ru-he-jian-xiao-shi-pin-shu-chu-da-xiao/</url>
      
        <content type="html"><![CDATA[<h1 id="producing-low-video-file-size-videos"><a href="#producing-low-video-file-size-videos" class="headerlink" title="producing low video file size videos"></a>producing low video file size videos</h1><p>视频基础系列课程：如何减小视频文件输出大小</p><div style="position: relative; width: 100%; height: 0; padding-bottom: 75%;"><iframe src="//player.bilibili.com/player.html?aid=25917381&cid=44337916&page=16" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true" style="position: absolute; width:100%; height:100%;left:0;top:0;"></iframe></div>]]></content>
      
      
      <categories>
          
          <category> 影音技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 视频基础 </tag>
            
            <tag> 视频公开课 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>视频基础系列课程15 如何提高视频质量</title>
      <link href="/2019/12/19/shi-pin-ji-chu-xi-lie-ke-cheng-15-ru-he-ti-gao-shi-pin-zhi-liang/"/>
      <url>/2019/12/19/shi-pin-ji-chu-xi-lie-ke-cheng-15-ru-he-ti-gao-shi-pin-zhi-liang/</url>
      
        <content type="html"><![CDATA[<h1 id="retainning-hight-quality-videos"><a href="#retainning-hight-quality-videos" class="headerlink" title="retainning hight quality videos"></a>retainning hight quality videos</h1><p>视频基础系列课程：如何提高视频质量</p><div style="position: relative; width: 100%; height: 0; padding-bottom: 75%;"><iframe src="//player.bilibili.com/player.html?aid=25917381&cid=44337912&page=15" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true" style="position: absolute; width:100%; height:100%;left:0;top:0;"></iframe></div>]]></content>
      
      
      <categories>
          
          <category> 影音技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 视频基础 </tag>
            
            <tag> 视频公开课 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>视频基础系列课程14 无损渲染和压缩</title>
      <link href="/2019/12/19/shi-pin-ji-chu-xi-lie-ke-cheng-14-shi-pin-wu-sun-xuan-ran-ya-suo/"/>
      <url>/2019/12/19/shi-pin-ji-chu-xi-lie-ke-cheng-14-shi-pin-wu-sun-xuan-ran-ya-suo/</url>
      
        <content type="html"><![CDATA[<h1 id="Lossless"><a href="#Lossless" class="headerlink" title="Lossless"></a>Lossless</h1><p>视频基础系列课程14 无损渲染压缩</p><div style="position: relative; width: 100%; height: 0; padding-bottom: 75%;"><iframe src="//player.bilibili.com/player.html?aid=25917381&cid=44337905&page=14" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true" style="position: absolute; width:100%; height:100%;left:0;top:0;"></iframe></div>]]></content>
      
      
      <categories>
          
          <category> 影音技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 视频基础 </tag>
            
            <tag> 视频公开课 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>视频基础系列课程13 视频中音频</title>
      <link href="/2019/12/19/shi-pin-ji-chu-xi-lie-ke-cheng-13-shi-pin-zhong-yin-pin/"/>
      <url>/2019/12/19/shi-pin-ji-chu-xi-lie-ke-cheng-13-shi-pin-zhong-yin-pin/</url>
      
        <content type="html"><![CDATA[<h1 id="Audio"><a href="#Audio" class="headerlink" title="Audio"></a>Audio</h1><p>视频基础系列课程13 视频中的音频</p><div style="position: relative; width: 100%; height: 0; padding-bottom: 75%;"><iframe src="//player.bilibili.com/player.html?aid=25917381&cid=44337899&page=13" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true" style="position: absolute; width:100%; height:100%;left:0;top:0;"></iframe></div>]]></content>
      
      
      <categories>
          
          <category> 影音技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 视频基础 </tag>
            
            <tag> 视频公开课 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>视频基础系列课程12 视频中的码率概念</title>
      <link href="/2019/12/19/shi-pin-ji-chu-xi-lie-ke-cheng-12-shi-pin-zhong-ma-lu-gai-nian/"/>
      <url>/2019/12/19/shi-pin-ji-chu-xi-lie-ke-cheng-12-shi-pin-zhong-ma-lu-gai-nian/</url>
      
        <content type="html"><![CDATA[<h1 id="Bitrate"><a href="#Bitrate" class="headerlink" title="Bitrate"></a>Bitrate</h1><p>视频基础系列课程12 视频中的码率概念</p><div style="position: relative; width: 100%; height: 0; padding-bottom: 75%;"><iframe src="//player.bilibili.com/player.html?aid=25917381&cid=44337895&page=12" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true" style="position: absolute; width:100%; height:100%;left:0;top:0;"></iframe></div>]]></content>
      
      
      <categories>
          
          <category> 影音技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 视频基础 </tag>
            
            <tag> 视频公开课 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>视频基础系列课程11 视频中的编解码器</title>
      <link href="/2019/12/19/shi-pin-ji-chu-xi-lie-ke-cheng-11-shi-pin-bian-jie-ma-qi/"/>
      <url>/2019/12/19/shi-pin-ji-chu-xi-lie-ke-cheng-11-shi-pin-bian-jie-ma-qi/</url>
      
        <content type="html"><![CDATA[<h1 id="Video-Codec-and-Compressions"><a href="#Video-Codec-and-Compressions" class="headerlink" title="Video Codec and Compressions"></a>Video Codec and Compressions</h1><p>视频基础系列课程11 视频中的编解码器</p><div style="position: relative; width: 100%; height: 0; padding-bottom: 75%;"><iframe src="//player.bilibili.com/player.html?aid=25917381&cid=44337891&page=11" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true" style="position: absolute; width:100%; height:100%;left:0;top:0;"></iframe></div>]]></content>
      
      
      <categories>
          
          <category> 影音技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 视频基础 </tag>
            
            <tag> 视频公开课 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>视频基础系列课程10 视频格式概念</title>
      <link href="/2019/12/19/shi-pin-ji-chu-xi-lie-ke-cheng-10-shi-pin-ge-shi-gai-nian/"/>
      <url>/2019/12/19/shi-pin-ji-chu-xi-lie-ke-cheng-10-shi-pin-ge-shi-gai-nian/</url>
      
        <content type="html"><![CDATA[<h1 id="video-Formats"><a href="#video-Formats" class="headerlink" title="video Formats"></a>video Formats</h1><p>视频基础系列课程10 视频格式概念</p><div style="position: relative; width: 100%; height: 0; padding-bottom: 75%;"><iframe src="//player.bilibili.com/player.html?aid=25917381&cid=44337880&page=10" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true" style="position: absolute; width:100%; height:100%;left:0;top:0;"></iframe></div>]]></content>
      
      
      <categories>
          
          <category> 影音技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 视频基础 </tag>
            
            <tag> 视频公开课 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>视频基础系列课程09 视频中的位深概念</title>
      <link href="/2019/12/19/shi-pin-ji-chu-xi-lie-ke-cheng-09-shi-pin-zhong-de-wei-shen-gai-nian/"/>
      <url>/2019/12/19/shi-pin-ji-chu-xi-lie-ke-cheng-09-shi-pin-zhong-de-wei-shen-gai-nian/</url>
      
        <content type="html"><![CDATA[<h1 id="Bit-Depth"><a href="#Bit-Depth" class="headerlink" title="Bit Depth"></a>Bit Depth</h1><p>视频基础系列课程09 视频中的位深概念</p><div style="position: relative; width: 100%; height: 0; padding-bottom: 75%;"><iframe src="//player.bilibili.com/player.html?aid=25917381&cid=44337871&page=9" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true" style="position: absolute; width:100%; height:100%;left:0;top:0;"></iframe></div>]]></content>
      
      
      <categories>
          
          <category> 影音技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 视频基础 </tag>
            
            <tag> 视频公开课 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>视频基础系列课程08 视频场概念</title>
      <link href="/2019/12/19/shi-pin-ji-chu-xi-lie-ke-cheng-08-shi-pin-chang-gai-nian/"/>
      <url>/2019/12/19/shi-pin-ji-chu-xi-lie-ke-cheng-08-shi-pin-chang-gai-nian/</url>
      
        <content type="html"><![CDATA[<h1 id="Field"><a href="#Field" class="headerlink" title="Field"></a>Field</h1><p>视频基础系列课程08 视频场概念</p><div style="position: relative; width: 100%; height: 0; padding-bottom: 75%;"><iframe src="//player.bilibili.com/player.html?aid=25917381&cid=44337859&page=8" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true" style="position: absolute; width:100%; height:100%;left:0;top:0;"></iframe></div>]]></content>
      
      
      <categories>
          
          <category> 影音技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 视频基础 </tag>
            
            <tag> 视频公开课 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>视频基础系列课程07 视频帧率概念</title>
      <link href="/2019/12/19/shi-pin-ji-chu-xi-lie-ke-cheng-07-shi-pin-zheng-lu/"/>
      <url>/2019/12/19/shi-pin-ji-chu-xi-lie-ke-cheng-07-shi-pin-zheng-lu/</url>
      
        <content type="html"><![CDATA[<h1 id="frame-rate"><a href="#frame-rate" class="headerlink" title="frame rate"></a>frame rate</h1><p>视频基础系列课程07 视频帧率概念</p><div style="position: relative; width: 100%; height: 0; padding-bottom: 75%;"><iframe src="//player.bilibili.com/player.html?aid=25917381&cid=44337853&page=7" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true" style="position: absolute; width:100%; height:100%;left:0;top:0;"></iframe></div>]]></content>
      
      
      <categories>
          
          <category> 影音技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 视频基础 </tag>
            
            <tag> 视频公开课 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>视频基础系列课程06 视频缩放剪裁</title>
      <link href="/2019/12/19/shi-pin-ji-chu-xi-lie-ke-cheng-06-shi-pin-suo-fang-jian-cai/"/>
      <url>/2019/12/19/shi-pin-ji-chu-xi-lie-ke-cheng-06-shi-pin-suo-fang-jian-cai/</url>
      
        <content type="html"><![CDATA[<h1 id="Letterboxing-and-stretching"><a href="#Letterboxing-and-stretching" class="headerlink" title="Letterboxing and stretching"></a>Letterboxing and stretching</h1><p>视频基础系列课程06 视频缩放剪裁</p><div style="position: relative; width: 100%; height: 0; padding-bottom: 75%;"><iframe src="//player.bilibili.com/player.html?aid=25917381&cid=44337845&page=6" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true" style="position: absolute; width:100%; height:100%;left:0;top:0;"></iframe></div>]]></content>
      
      
      <categories>
          
          <category> 影音技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 视频基础 </tag>
            
            <tag> 视频公开课 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>视频基础系列课程05 中期总结</title>
      <link href="/2019/12/19/shi-pin-ji-chu-xi-lie-ke-cheng-05-zhong-qi-zong-jie/"/>
      <url>/2019/12/19/shi-pin-ji-chu-xi-lie-ke-cheng-05-zhong-qi-zong-jie/</url>
      
        <content type="html"><![CDATA[<h1 id="05-How-they-function-togather"><a href="#05-How-they-function-togather" class="headerlink" title="05 How they function togather"></a>05 How they function togather</h1><p>总结前面课程，综合前面所讲概念。</p><div style="position: relative; width: 100%; height: 0; padding-bottom: 75%;"><iframe src="//player.bilibili.com/player.html?aid=25917381&cid=44337839&page=5" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true" style="position: absolute; width:100%; height:100%;left:0;top:0;"></iframe></div>]]></content>
      
      
      <categories>
          
          <category> 影音技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 视频基础 </tag>
            
            <tag> 视频公开课 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>视频基础系列课程04 像素宽高比</title>
      <link href="/2019/12/19/shi-pin-ji-chu-xi-lie-ke-cheng-04-xiang-su-kuan-gao-bi/"/>
      <url>/2019/12/19/shi-pin-ji-chu-xi-lie-ke-cheng-04-xiang-su-kuan-gao-bi/</url>
      
        <content type="html"><![CDATA[<h1 id="04-Pixel-Aspect-Ratios-（像素宽高比）"><a href="#04-Pixel-Aspect-Ratios-（像素宽高比）" class="headerlink" title="04 Pixel Aspect Ratios （像素宽高比）"></a>04 Pixel Aspect Ratios （像素宽高比）</h1><p>像素比是指图像中的一个像素的宽度与高度之比，而帧纵横比则是指图像的一帧的宽度与高度之比。</p><p>图像中的一个像素的宽度与高度之比，而帧纵横比则是指图像的一帧的宽度与高度之比。如某些D1/DV NTSC图像的帧纵横比是4：3，但使用方形像素（1.0像素比）的是640×480，使用矩形像素（0.9像素比）的是720×480。DV基本上使用矩形像素，在NTSC视频中是纵向排列的，而在PAL制视频中是横向排列的。使用计算机图形软件制作生成的图像大多使用方形像素。</p><p>由于计算机产生的图像的像素比永远是1:1，而由于电视设备所产生的视频图像，就不一定是1:1，如我国的PAL制像素比就是16:15=1.07。同时，PAL制规定画面宽高比为4:3。根据宽高比的定义来推算， PAL制图像分辨率应为768<em>576，这是在像素为1:1的情况下，可PAL制的分辨率为720</em>576。因此，实际PAL制图像的像素比是768:720=16:15=1.07。也就是通过把正方形像素“拉长”的方法，保证了画面的4:3的宽高比例。</p><div style="position: relative; width: 100%; height: 0; padding-bottom: 75%;"><iframe src="//player.bilibili.com/player.html?aid=25917381&cid=44337835&page=4" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true" style="position: absolute; width:100%; height:100%;left:0;top:0;"> </iframe></div>]]></content>
      
      
      <categories>
          
          <category> 影音技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 视频基础 </tag>
            
            <tag> 视频公开课 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>视频基础系列课程03宽高比</title>
      <link href="/2019/12/19/shi-pin-ji-chu-xi-lie-ke-cheng-03-kuan-gao-bi/"/>
      <url>/2019/12/19/shi-pin-ji-chu-xi-lie-ke-cheng-03-kuan-gao-bi/</url>
      
        <content type="html"><![CDATA[<h1 id="03-Aspect-Ratios-（宽高比）"><a href="#03-Aspect-Ratios-（宽高比）" class="headerlink" title="03 Aspect Ratios （宽高比）"></a>03 Aspect Ratios （宽高比）</h1><p>宽高比即是视频显示的宽度与高度的比例。宽高比最初用于电影中，其标准宽高比为4:3，后来这个比例也延续到了电视以及早期的电脑显示器中。之后随着技术的改进，影视以及显示设备发展到了更宽的比例，就出现了16:9、16:10等宽屏比例。</p><img src="/2019/12/19/shi-pin-ji-chu-xi-lie-ke-cheng-03-kuan-gao-bi/1.jpg" class="" title="宽高比"><h2 id="常见宽高比对应的分辨率有哪些？"><a href="#常见宽高比对应的分辨率有哪些？" class="headerlink" title="常见宽高比对应的分辨率有哪些？"></a>常见宽高比对应的分辨率有哪些？</h2><p>4:3宽高比的分辨率 — 640<em>480、800</em>600、960<em>720、1024</em>768、1280<em>960、1440</em>1080、1600<em>1200、1920</em>1440、2048*1536等。</p><h2 id="为什么视频会有黑边？"><a href="#为什么视频会有黑边？" class="headerlink" title="为什么视频会有黑边？"></a>为什么视频会有黑边？</h2><p>很多时候，我们在播放某个视频时，会发现视频的上下或左右有黑边，影响观看。这些黑边是怎么来的呢？其实，是因为我们在16:9的播放窗口中观看的是4:3的视频，由于视频的宽高比与播放器的宽高比不同，才会导致视频有黑边出现。</p><div style="position: relative; width: 100%; height: 0; padding-bottom: 75%;"><iframe src="//player.bilibili.com/player.html?aid=25917381&cid=44337827&page=3" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true" style="position: absolute; width:100%; height:100%;left:0;top:0;"> </iframe></div>]]></content>
      
      
      <categories>
          
          <category> 影音技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 视频基础 </tag>
            
            <tag> 视频公开课 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>视频基础系列课程02分辨率与大小</title>
      <link href="/2019/12/19/shi-pin-ji-chu-xi-lie-ke-cheng-02-fen-bian-lu-yu-da-xiao/"/>
      <url>/2019/12/19/shi-pin-ji-chu-xi-lie-ke-cheng-02-fen-bian-lu-yu-da-xiao/</url>
      
        <content type="html"><![CDATA[<h1 id="02-Resolution-amp-Size-（视频分辨率）"><a href="#02-Resolution-amp-Size-（视频分辨率）" class="headerlink" title="02 Resolution &amp; Size （视频分辨率）"></a>02 Resolution &amp; Size （视频分辨率）</h1><p>视频分辨率是用于度量图像内数据量多少的一个参数，通常表示成ppi（每英寸像素Pixel per inch）一个视频的320X180是指它在横向和纵向上的有效像素，窗口小时ppi值较高，看起来清晰；窗口放大时，由于没有那么多有效像素填充窗口，有效像素ppi值下降，就模糊了。（放大时有效像素间的距离拉大，而显卡会把这些空隙填满，也就是插值，插值所用的像素是根据上下左右的有效像素“猜”出来的“假像素”，没有原视频信息）习惯上我们说的分辨率是指图像的高/宽像素值，严格意义上的分辨率是指单位长度内的有效像素值ppi。差别就在这里。图像的高/宽像素值的确和尺寸无关，但单位长度内的有效像素值ppi和尺寸就有关了，显然尺寸越大ppi越小。</p><div style="position: relative; width: 100%; height: 0; padding-bottom: 75%;"><iframe src="//player.bilibili.com/player.html?aid=25917381&cid=44337820&page=2" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true" style="position: absolute; width:100%; height:100%;left:0;top:0;"> </iframe></div><p>更多视频技术基础课程，请关注MouseMedia.</p>]]></content>
      
      
      <categories>
          
          <category> 影音技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 视频基础 </tag>
            
            <tag> 视频公开课 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>视频技术基础系列课程 01简介</title>
      <link href="/2019/12/19/shi-pin-ji-chu-xi-lie-ke-cheng-01-jian-jie/"/>
      <url>/2019/12/19/shi-pin-ji-chu-xi-lie-ke-cheng-01-jian-jie/</url>
      
        <content type="html"><![CDATA[<p>本文所有视频转载自B站的视频编解码技术基础系列视频课程。</p><h1 id="01-Introduction-简介"><a href="#01-Introduction-简介" class="headerlink" title="01_Introduction (简介)"></a>01_Introduction (简介)</h1><p>本系列是视频基础系列课程，针对特效视频渲染的入门级用户。<br>主要涉及视频的一些基础概念，如分辨率，大小，宽高比等。</p><div style="position: relative; width: 100%; height: 0; padding-bottom: 75%;"><iframe src="//player.bilibili.com/player.html?aid=25917381&cid=44337819&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true" style="position: absolute; width:100%; height:100%;left:0;top:0;"> </iframe></div><p>后续影音视频基础课程系列，请关注。</p>]]></content>
      
      
      <categories>
          
          <category> 影音技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 视频基础 </tag>
            
            <tag> 视频公开课 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于Chrome V8 引擎</title>
      <link href="/2019/12/19/guan-yu-chrome-v8-yin-qing/"/>
      <url>/2019/12/19/guan-yu-chrome-v8-yin-qing/</url>
      
        <content type="html"><![CDATA[<p> 随着Web相关技术的发展，JavaScript所要承担的工作也越来越多，早就超越了“表单验证”的范畴，这就更需要快速的解析和执行JavaScript脚本。V8引擎就是为解决这一问题而生，在node中也是采用该引擎来解析JavaScript。V8是如何使得JavaScript性能有大幅提升的呢？通过对一些书籍和文章的学习，梳理了V8的相关内容，本文将带你认识 V8。</p><h2 id="1-渲染引擎及网页渲染"><a href="#1-渲染引擎及网页渲染" class="headerlink" title="1.渲染引擎及网页渲染"></a>1.渲染引擎及网页渲染</h2><p>浏览器自从上世纪80年代后期90年代初期诞生以来，已经得到了长足的发展，其功能也越来越丰富，包括网络、资源管理、网页浏览、多页面管理、插件和扩展、书签管理、历史记录管理、设置管理、下载管理、账户和同步、安全机制、隐私管理、外观主题、开发者工具等。在这些功能中，为用户提供网页浏览服务无疑是最重要的功能，下面将对相关内容进行介绍。</p><h3 id="1-1-渲染引擎"><a href="#1-1-渲染引擎" class="headerlink" title="1.1.渲染引擎"></a>1.1.渲染引擎</h3><p>渲染引擎：能够将HTML/CSS/JavaScript文本及相应的资源文件转换成图像结果。渲染引擎的主要作用是将资源文件转化为用户可见的结果。在浏览器的发展过程中，不同的厂商开发了不同的渲染引擎，如Tridend(IE)、Gecko(FF)、WebKit(Safari,Chrome,Andriod浏览器)等。WebKit是由苹果2005年发起的一个开源项目，引起了众多公司的重视，几年间被很多公司所采用，在移动端更占据了垄断地位。更有甚者，开发出了基于WebKit的支持HTML5的web操作系统(如：Chrome OS、Web OS)。</p><p>下面是WebKit的大致结构：</p><img src="/2019/12/19/guan-yu-chrome-v8-yin-qing/1.png" class="" title="webkit架构"><p>上图中实线框内模块是所有移植的共有部分，虚线框内不同的厂商可以自己实现。下面进行介绍：</p><ul><li>操作系统：是管理和控制计算机硬件与软件资源的计算机程序，是直接运行在“裸机”上的最基本的系统软件，任何其他软件都必须在操作系统的支持下才能运行。WebKit也是在操作系统上工作的。</li></ul><ul><li>第三方库，为了WebKit提供支持，如图形库、网络库、视频库等。<br>WebCore 是各个浏览器使用的共享部分，包括HTML解析器、CSS解析器、DOM和SVG等。JavaScriptCore是WebKit的默认引擎，在谷歌系列产品中被替换为V8引擎。</li></ul><ul><li>WebKit Ports是WebKit中的非共享部分，由于平台差异、第三方库和需求的不同等原因，不同的移植导致了WebKit不同版本行为不一致，它是不同浏览器性能和功能差异的关键部分。<br>WebKit嵌入式编程接口，供浏览器调用，与移植密切相关，不同的移植有不同的接口规范。</li></ul><ul><li>测试用例，包括布局测试用例和性能测试用例，用来验证渲染结果的正确性。</li></ul><h3 id="1-2-网页渲染流程"><a href="#1-2-网页渲染流程" class="headerlink" title="1.2.网页渲染流程"></a>1.2.网页渲染流程</h3><p>上面介绍了渲染引擎的各个模块，那么一张网页，要经历怎样的过程，才能抵达用户面前？</p><img src="/2019/12/19/guan-yu-chrome-v8-yin-qing/2.png" class="" title="渲染流程"><p>首先是网页内容，输入到HTML解析器，HTML解析器解析，然后构建DOM树，在这期间如果遇到JavaScript代码则交给JavaScript引擎处理；如果来自CSS解析器的样式信息，构建一个内部绘图模型。该模型由布局模块计算模型内部各个元素的位置和大小信息，最后由绘图模块完成从该模型到图像的绘制。在网页渲染的过程中，大致可分为下面3个阶段。</p><h4 id="1-2-1-从输入URL到生成DOM树"><a href="#1-2-1-从输入URL到生成DOM树" class="headerlink" title="1.2.1.从输入URL到生成DOM树"></a>1.2.1.从输入URL到生成DOM树</h4><ul><li>地址栏输入URL，WebKit调用资源加载器加载相应资源；</li></ul><ul><li>加载器依赖网络模块建立连接，发送请求并接收答复；</li><li>WebKit接收各种网页或者资源数据，其中某些资源可能同步或异步获取；</li><li>网页交给HTML解析器转变为词语；</li><li>解释器根据词语构建节点，形成DOM树；</li><li>如果节点是JavaScript代码，调用JavaScript引擎解释并执行；</li><li>JavaScript代码可能会修改DOM树结构；</li><li>如果节点依赖其他资源，如图片\css、视频等，调用资源加载器加载它们，但这些是异步加载的，不会阻碍当前DOM树继续创建；如果是JavaScript资源URL（没有标记异步方式），则需要停止当前DOM树创建，直到JavaScript加载并被JavaScript引擎执行后才继续DOM树的创建。</li></ul><h4 id="1-2-2-从DOM树到构建WebKit绘图上下文"><a href="#1-2-2-从DOM树到构建WebKit绘图上下文" class="headerlink" title="1.2.2.从DOM树到构建WebKit绘图上下文"></a>1.2.2.从DOM树到构建WebKit绘图上下文</h4><ul><li><p>CSS文件被CSS解释器解释成内部表示；</p></li><li><p>CSS解释器完成工作后，在DOM树上附加样式信息，生成RenderObject树；</p></li><li><p>RenderObject节点在创建的同时，WebKit会根据网页层次结构构建RenderLayer树，同时构建一个虚拟绘图上下文。</p></li></ul><h4 id="1-2-3-绘图上下文到最终图像呈现"><a href="#1-2-3-绘图上下文到最终图像呈现" class="headerlink" title="1.2.3.绘图上下文到最终图像呈现"></a>1.2.3.绘图上下文到最终图像呈现</h4><p>绘图上下文是一个与平台无关的抽象类，它将每个绘图操作桥接到不同的具体实现类，也就是绘图具体实现类；<br>绘图实现类也可能有简单的实现，也可能有复杂的实现，软件渲染、硬件渲染、合成渲染等；<br>绘图实现类将2D图形库或者3D图形库绘制结果保存，交给浏览器界面进行展示。<br>　　上述是一个完整的渲染过程，现代网页很多都是动态的，随着网页与用户的交互，浏览器需要不断的重复渲染过程。</p><h3 id="1-3-JavaScript引擎"><a href="#1-3-JavaScript引擎" class="headerlink" title="1.3.JavaScript引擎"></a>1.3.JavaScript引擎</h3><img src="/2019/12/19/guan-yu-chrome-v8-yin-qing/3.png" class=""><p>JavaScript本质上是一种解释型语言，与编译型语言不同的是它需要一遍执行一边解析，而编译型语言在执行时已经完成编译，可直接执行，有更快的执行速度(如上图所示)。JavaScript代码是在浏览器端解析和执行的，如果需要时间太长，会影响用户体验。那么提高JavaScript的解析速度就是当务之急。JavaScript引擎和渲染引擎的关系如下图所示：</p><img src="/2019/12/19/guan-yu-chrome-v8-yin-qing/4.png" class=""><p>JavaScript语言是解释型语言，为了提高性能，引入了Java虚拟机和C++编译器中的众多技术。现在JavaScript引擎的执行过程大致是：</p><p>　　源代码-→抽象语法树-→字节码-→JIT-→本地代码(V8引擎没有中间字节码)。一段代码的抽象语法树示例如下：</p><pre><code>function demo(name) {   console.log(name);}</code></pre><p>抽象语法树如下：</p><img src="/2019/12/19/guan-yu-chrome-v8-yin-qing/5.png" class=""><p>V8更加直接的将抽象语法树通过JIT技术转换成本地代码，放弃了在字节码阶段可以进行的一些性能优化，但保证了执行速度。在V8生成本地代码后，也会通过Profiler采集一些信息，来优化本地代码。虽然，少了生成字节码这一阶段的性能优化，但极大减少了转换时间。</p><p>但是在2017年4月底，v8 的 5.9 版本发布了，新增了一个 Ignition 字节码解释器，将默认启动，从此之后将与JSCore有大致相同的流程。做出这一改变的原因为：（主要动机）减轻机器码占用的内存空间，即牺牲时间换空间；提高代码的启动速度；对 v8 的代码进行重构，降低 v8 的代码复杂度.</p><p>JavaScript的性能和C相比还有不小的距离，可预见的未来估计也只能接近它，而不是与它相比，这从语言类型上已经决定。下面将对V8引擎进行更为细致的介绍。</p><h2 id="2-V8引擎"><a href="#2-V8引擎" class="headerlink" title="2.V8引擎"></a>2.V8引擎</h2><p>V8引擎是一个JavaScript引擎实现，最初由一些语言方面专家设计，后被谷歌收购，随后谷歌对其进行了开源。V8使用C++开发，，在运行JavaScript之前，相比其它的JavaScript的引擎转换成字节码或解释执行，V8将其编译成原生机器码（IA-32, x86-64, ARM, or MIPS CPUs），并且使用了如内联缓存（inline caching）等方法来提高性能。有了这些功能，JavaScript程序在V8引擎下的运行速度媲美二进制程序。V8支持众多操作系统，如windows、linux、android等，也支持其他硬件架构，如IA32,X64,ARM等，具有很好的可移植和跨平台特性。<br>　　V8项目代码结构如下：</p><img src="/2019/12/19/guan-yu-chrome-v8-yin-qing/6.png" class=""><h3 id="2-1-数据表示"><a href="#2-1-数据表示" class="headerlink" title="2.1.数据表示"></a>2.1.数据表示</h3><p>JavaScript是一种无类型语言，在编译时并不能准确知道变量的类型，只可以在运行时确定，这就不像c++或者java等静态类型语言，在编译时候就可以确切知道变量的类型。然而，在运行时计算和决定类型，会严重影响语言性能，这也就是JavaScript运行效率比C++或者JAVA低很多的原因之一。</p><p>在C++中，源代码需要经过编译才能执行，在生成本地代码的过程中，变量的地址和类型已经确定，运行本地代码时利用数组和位移就可以存取变量和方法的地址，不需要再进行额外的查找，几个机器指令即可完成，节省了确定类型和地址的时间。由于JavaScript是无类型语言，那就不能像c++那样在执行时已经知道变量的类型和地址，需要临时确定。JavaScript 和C++有以下几个区别：</p><p>编译确定位置，C++编译阶段确定位置偏移信息，在执行时直接存取，JavaScript在执行阶段确定，而且执行期间可以修改对象属性；<br>偏移信息共享，C++有类型定义，执行时不能动态改变，可共享偏移信息，JavaScript每个对象都是自描述，属性和位置偏移信息都包含在自身的结构中；</p><p>偏移信息查找，C++查找偏移地址很简单，在编译代码阶段，对使用的某类型成员变量直接设置偏移位置，JavaScript中使用一个对象，需要通过属性名匹配才能找到相应的值，需要更多的操作。</p><p>在代码执行过程中，变量的存取是非常普遍和频繁的，通过偏移量来存取，使用少数两个汇编指令就能完成，如果通过属性名匹配则需要更多的汇编指令，也需要更多的内存空间。示例如下：</p><img src="/2019/12/19/guan-yu-chrome-v8-yin-qing/7.jpg" class=""><p>在JavaScript中，除boolean，number，string，null，undefined这个五个简单变量外，其他的数据都是对象，V8使用一种特殊的方式来表示它们，进而优化JavaScript的内部表示问题。</p><p>在V8中，数据的内部表示由数据的实际内容和数据的句柄构成。数据的实际内容是变长的，类型也是不同的；句柄固定大小，包含指向数据的指针。这种设计可以方便V8进行垃圾回收和移动数据内容，如果直接使用指针的话就会出问题或者需要更大的开销，使用句柄的话，只需修改句柄中的指针即可，使用者使用的还是句柄，指针改动是对使用者透明的。</p><p>除少数数据(如整型数据)由handle本身存储外，其他内容限于句柄大小和变长等原因，都存储在堆中。整数直接从value中取值，然后使用一个指针指向它，可以减少内存的占用并提高访问速度。一个句柄对象的大小是4字节(32位设备)或者8字节(64位设备)，而在JavaScriptCore中，使用的8个字节表示句柄。在堆中存放的对象都是4字节对齐的，所以它们指针的后两位是不需要的，V8用这两位表示数据的类型，00为整数，01为其他。</p><p>JavaScript对象在V8中的实现包含三个部分：隐藏类指针，这是v8为JavaScript对象创建的隐藏类；属性值表指针，指向该对象包含的属性值；元素表指针，指向该对象包含的属性。</p><h3 id="2-2-工作过程"><a href="#2-2-工作过程" class="headerlink" title="2.2.工作过程"></a>2.2.工作过程</h3><p>前面有过介绍，V8引擎在执行JavaScript的过程中，主要有两个阶段：编译和运行，与C++的执行前完全编译不同的是，JavaScript需要在用户使用时完成编译和执行。在V8中，JavaScript相关代码并非一下完成编译的，而是在某些代码需要执行时，才会进行编译，这就提高了响应时间，减少了时间开销。在V8引擎中，源代码先被解析器转变为抽象语法树(AST)，然后使用JIT编译器的全代码生成器从AST直接生成本地可执行代码。这个过程不同于JAVA先生成字节码或中间表示，减少了AST到字节码的转换时间，提高了代码的执行速度。但由于缺少了转换为字节码这一中间过程，也就减少了优化代码的机会。</p><p>V8引擎编译本地代码时使用的主要类如下所示：</p><ul><li>Script：表示JavaScript代码，即包含源代码，又包含编译之后生成的本地代码，即是编译入口，又是运行入口；</li><li>Compiler：编译器类，辅组Script类来编译生成代码，调用解释器(Parser)来生成AST和全代码生成器，将AST转变为本地代码；</li><li>AstNode：抽象语法树节点类，是其他所有节点的基类，包含非常多的子类，后面会针对不同的子类生成不同的本地代码；</li><li>AstVisitor：抽象语法树的访问者类，主要用来遍历异构的抽象语法树；</li><li>FullCodeGenerator：AstVisitor类的子类，通过遍历AST来为JavaScript生成本地可执行代码。</li></ul><img src="/2019/12/19/guan-yu-chrome-v8-yin-qing/7.png" class=""><p>JavaScript代码编译的过程大致为：Script类调用Compiler类的Compile函数为其生成本地代码。Compile函数先使用Parser类生成AST，再使用FullCodeGenerator类来生成本地代码。本地代码与具体的硬件平台密切相关，FullCodeGenerator使用多个后端来生成与平台相匹配的本地汇编代码。由于FullCodeGenerator通过遍历AST来为每个节点生成相应的汇编代码，缺失了全局视图，节点之间的优化也就无从谈起。</p><p>在执行编译之前，V8会构建众多全局对象并加载一些内置的库（如math库），来构建一个运行环境。而且在JavaScript源代码中，并非所有的函数都被编译生成本地代码，而是延迟编译，在调用时才会编译。</p><p>由于V8缺少了生成中间代码这一环节，缺少了必要的优化，为了提升性能，V8会在生成本地代码后，使用数据分析器(profiler)采集一些信息，然后根据这些数据将本地代码进行优化，生成更高效的本地代码，这是一个逐步改进的过程。同时，当发现优化后代码的性能还不如未优化的代码，V8将退回原来的代码，也就是优化回滚。下面介绍一下运行阶段，该阶段使用的主要类如下所示：</p><ul><li>Script：表示JavaScript代码，即包含源代码，又包含编译之后生成的本地代码，即是编译入口，又是运行入口；</li><li>Execution：运行代码的辅组类，包含一些重要函数，如Call函数，它辅组进入和执行Script代码；</li><li>JSFunction：需要执行的JavaScript函数表示类；</li><li>Runtime：运行这些本地代码的辅组类，主要提供运行时所需的辅组函数，如：属性访问、类型转换、编译、算术、位操作、比较、正则表达式等；</li><li>Heap：运行本地代码需要使用的内存堆类；</li><li>MarkCompactCollector：垃圾回收机制的主要实现类，用来标记、清除和整理等基本的垃圾回收过程；</li><li>SweeperThread：负责垃圾回收的线程。<img src="/2019/12/19/guan-yu-chrome-v8-yin-qing/8.png" class=""></li></ul><p>先根据需要编译和生成这些本地代码，也就是使用编译阶段那些类和操作。在V8中，函数是一个基本单位，当某个JavaScript函数被调用时，V8会查找该函数是否已经生成本地代码，如果已经生成，则直接调用该函数。否则，V8引擎会生成属于该函数的本地代码。这就节约了时间，减少了处理那些使用不到的代码的时间。其次，执行编译后的代码为JavaScript构建JS对象，这需要Runtime类来辅组创建对象，并需要从Heap类分配内存。再次，借助Runtime类中的辅组函数来完成一些功能，如属性访问等。最后，将不用的空间进行标记清除和垃圾回收。</p><h3 id="2-3-优化回滚"><a href="#2-3-优化回滚" class="headerlink" title="2.3.优化回滚"></a>2.3.优化回滚</h3><p>因为V8是基于AST直接生成本地代码，没有经过中间表示层的优化，所以本地代码尚未经过很好的优化。于是，在2010年，V8引入了新的编译器-Crankshaft，它主要针对热点函数进行优化，基于JavaScript源代码开始分析而非本地代码，同时构建Hydroger图并基于此来进行优化分析。</p><p>Crankshaft编译器为了性能考虑，通常会做出比较乐观和大胆的预测—代码稳定且变量类型不变，所以可以生成高效的本地代码。但是，鉴于JavaScript的一个弱类型的语言，变量类型也可能在执行的过程中进行改变，鉴于这种情况，V8会将该编译器做的想当然的优化进行回滚，称为优化回滚。</p><p>　　示例如下：</p><pre><code>var counter = 0;function test(x, y) {    counter++;    if (counter &lt; 1000000) {           // do something           return &#39;jeri&#39;;    }    var unknown = new Date();    console.log(unknown);}</code></pre><p>该函数被调用多次之后，V8引擎可能会触发Crankshaft编译器对其进行优化，而优化代码认为示例代码的类型信息都已经被确定。但，由于尚未真正执行到new Date()这个地方，并未获取unknown这个变量的类型，V8只得将该部分代码进行回滚。优化回滚是一个很耗时的操作，在写代码过程中，尽量不要触发优化该操作。</p><p>在最近发布的 V8 5.9 版本中，新增了一个 Ignition 字节码解释器，TurboFan 和 Ignition 结合起来共同完成JavaScript的编译。这个版本中消除 Cranshaft 这个旧的编译器，并让新的 Turbofan 直接从字节码来优化代码，并当需要进行反优化的时候直接反优化到字节码，而不需要再考虑 JS 源代码。</p><h3 id="2-4-隐藏类与内嵌缓存"><a href="#2-4-隐藏类与内嵌缓存" class="headerlink" title="2.4.隐藏类与内嵌缓存"></a>2.4.隐藏类与内嵌缓存</h3><h4 id="2-4-1-隐藏类"><a href="#2-4-1-隐藏类" class="headerlink" title="2.4.1.隐藏类"></a>2.4.1.隐藏类</h4><p>在执行C++代码时，仅凭几个指令即可根据偏移信息获取变量信息，而JavaScript里需要通过字符串匹配来查找属性值的，这就需要更多的操作才能访问到变量信息，而代码量变量存取是十分频繁的，这也就制约了JavaScript的性能。V8借用了类和偏移位置的思想，将本来通过属性名匹配来访问属性值的方法进行了改进，使用类似C++编译器的偏移位置机制来实现，这就是隐藏类。</p><p>隐藏类将对象划分成不同的组，对于组内对象拥有相同的属性名和属性值的情况，将这些组的属性名和对应的偏移位置保存在一个隐藏类中，组内所有对象共享该信息。同时，也可以识别属性不同的对象。示例如下：</p><img src="/2019/12/19/guan-yu-chrome-v8-yin-qing/9.png" class=""><p>使用Point构造了两个对象p和q，这两个对象具有相同的属性名，V8将它们归为同一个组，也就是隐藏类，这些属性在隐藏类中有相同的偏移值，p和q共享这一信息，进行属性访问时，只需根据隐藏类的偏移值即可。由于JavaScript是动态类型语言，在执行时可以更改变量的类型，如果上述代码执行之后，执行q.z=2，那么p和q将不再被认为是一个组，q将是一个新的隐藏类。</p><h4 id="2-4-2-内嵌缓存"><a href="#2-4-2-内嵌缓存" class="headerlink" title="2.4.2.内嵌缓存"></a>2.4.2.内嵌缓存</h4><p>正常访问对象属性的过程是：首先获取隐藏类的地址，然后根据属性名查找偏移值，然后计算该属性的地址。虽然相比以往在整个执行环境中查找减小了很大的工作量，但依然比较耗时。能不能将之前查询的结果缓存起来，供再次访问呢？当然是可行的，这就是内嵌缓存。</p><p>内嵌缓存的大致思路就是将初次查找的隐藏类和偏移值保存起来，当下次查找的时候，先比较当前对象是否是之前的隐藏类，如果是的话，直接使用之前的缓存结果，减少再次查找表的时间。当然，如果一个对象有多个属性，那么缓存失误的概率就会提高，因为某个属性的类型变化之后，对象的隐藏类也会变化，就与之前的缓存不一致，需要重新使用以前的方式查找哈希表。</p><h3 id="2-5-内存管理"><a href="#2-5-内存管理" class="headerlink" title="2.5.内存管理"></a>2.5.内存管理</h3><p>Node中通过JavaScript使用内存时就会发现只能使用部分内存（64位系统下约为1.4 GB，32位系统下约为0.7 GB），其深层原因是 V8 垃圾回收机制的限制所致（如果可使用内存太大，V8在进行垃圾回收时需耗费更多的资源和时间，严重影响JS的执行效率）。下面对内存管理进行介绍。</p><p>内存的管理组要由分配和回收两个部分构成。V8的内存划分如下：</p><ul><li>Zone：管理小块内存。其先自己申请一块内存，然后管理和分配一些小内存，当一块小内存被分配之后，不能被Zone回收，只能一次性回收Zone分配的所有小内存。当一个过程需要很多内存，Zone将需要分配大量的内存，却又不能及时回收，会导致内存不足情况。</li><li>堆：管理JavaScript使用的数据、生成的代码、哈希表等。为方便实现垃圾回收，堆被分为三个部分：</li><li>年轻分代：为新创建的对象分配内存空间，经常需要进行垃圾回收。为方便年轻分代中的内容回收，可再将年轻分代分为两半，一半用来分配，另一半在回收时负责将之前还需要保留的对象复制过来。</li><li>年老分代：根据需要将年老的对象、指针、代码等数据保存起来，较少地进行垃圾回收。</li><li>大对象：为那些需要使用较多内存对象分配内存，当然同样可能包含数据和代码等分配的内存，一个页面只分配一个对象。</li></ul><img src="/2019/12/19/guan-yu-chrome-v8-yin-qing/10.png" class=""><p>垃圾回收</p><blockquote><p>V8 使用了分代和大数据的内存分配，在回收内存时使用精简整理的算法标记未引用的对象，然后消除没有标记的对象，最后整理和压缩那些还未保存的对象，即可完成垃圾回收。</p></blockquote><blockquote><p>在V8中，使用较多的是年轻分代和年老分代。年轻分代中的对象垃圾回收主要通过Scavenge算法进行垃圾回收。在Scavenge的具体实现中，主要采用了Cheney算法：通过复制的方式实现的垃圾回收算法。它将堆内存分为两个 semispace，一个处于使用中（From空间），另一个处于闲置状态（To空间）。当分配对象时，先是在From空间中进行分配。当开始进行垃圾回收时，会检查From空间中的存活对象，这些存活对象将被复制到To空间中，而非存活对象占用的空间将会被释放。完成复制后，From空间和To空间的角色发生对换。在垃圾回收的过程中，就是通过将存活对象在两个 semispace 空间之间进行复制。年轻分代中的对象有机会晋升为年老分代，条件主要有两个：一个是对象是否经历过Scavenge回收，一个是To空间的内存占用比超过限制。</p></blockquote><blockquote><p>对于年老分代中的对象，由于存活对象占较大比重，再采用上面的方式会有两个问题：一个是存活对象较多，复制存活对象的效率将会很低；另一个问题依然是浪费一半空间的问题。为此，V8在年老分代中主要采用了Mark-Sweep（标记清除）标记清除和Mark-Compact（标记整理）相结合的方式进行垃圾回收。</p></blockquote><h3 id="2-6-快照"><a href="#2-6-快照" class="headerlink" title="2.6.快照"></a>2.6.快照</h3><p>在V8引擎启动时，需要构建JavaScript运行环境，需要加载很多内置对象，同时也需要建立内置的函数，如Array，String，Math等。为了使V8更加整洁，加载对象和建立函数等任务都是使用JavaScript文件来实现的，V8引擎负责提供机制来支持，就是在编译和执行JavaScript前先加载这些文件。</p><p>V8引擎需要编译和执行这些内置的JavaScript代码，同时使用堆等来保存执行过程中创建的对象、代码等，这些都需要时间。为此，V8引入了快照机制。将这些内置的对象和函数加载之后的内存保存并序列化。序列化之后的结果很容易反序列化，经过快照机制的启动时间可以缩减几毫秒。快照机制也可以将一些开发者认为需要的JavaScript文件序列化，以减少处理时间。不过快照机制的加载的代码不能被CrankShaft这样的编译器优化，可能会存在性能问题。</p><h2 id="3-V8-VS-JavaScriptCore"><a href="#3-V8-VS-JavaScriptCore" class="headerlink" title="3 V8 VS JavaScriptCore"></a>3 V8 VS JavaScriptCore</h2><p>JavaScriptCore引擎是WebKit中默认的JavaScript引擎，也是苹果开源的一个项目，应用较为广泛。最初，性能不是很好，从2008年开始了一系列的优化，重新实现了编译器和字节码解释器，使得引擎的性能有较大的提升。随后内嵌缓存、基于正则表达式的JIT、简单的JIT及字节码解释器等技术引入进来，JavaScriptCore引擎也在不断的迭代和发展。</p><p>V8引擎自诞生之日起就以性能优化作为目标，引入了众多新技术，极大了带动了整个业界JavaScript引擎性能的快速发展。总的来说，V8引擎较为激进，青睐可以提高性能的新技术，而JavaScriptCore引擎较为稳健，渐进式的改变着自己的性能。总的来说JavaScript引擎工作流程（包含v8和JavaScriptCore）如下所示：</p><img src="/2019/12/19/guan-yu-chrome-v8-yin-qing/11.png" class=""><p>JavaScriptCore 的大致流程为：源代码-→抽象语法树-→字节码-→JIT-→本地代码。JavaScriptCore与V8有一些不同之处，其中最大的不同就是新增了字节码的中间表示，并加入了多层JIT编译器（如：简单JIT编译器、DFG JIT编译器、LLVM等）优化性能，不停的对本地代码进行优化。(在 V8 的 5.9 版本中，新增了一个 Ignition 字节码解释器，TurboFan 和 Ignition 结合起来共同完成JavaScript的编译，此后 V8 将与 JavaScriptCore 有大致相同的流程，Node 8.0中 V8 版本为 5.8)</p><p>还有就是在数据表示方面，V8在不同的机器上使用与机器位数相匹配的数据表示，而在JavaScriptCore中句柄都是使用64位表示，其可以表示更大范围的数字，所以即使在32位机器上，浮点类型同样可以保存在句柄中，不再需要访问堆中的数据，当也会占用更多的空间。</p><h2 id="4-功能扩展"><a href="#4-功能扩展" class="headerlink" title="4.功能扩展"></a>4.功能扩展</h2><p>JavaScript引擎的主要功能是解析和执行JavaScript代码，往往不能满足使用者多样化的需要，那么就可以增加扩展以提升它的能力。V8引擎有两种扩展机制：绑定和扩展。</p><h3 id="4-1-绑定机制"><a href="#4-1-绑定机制" class="headerlink" title="4.1.绑定机制"></a>4.1.绑定机制</h3><p>使用IDL文件或接口文件生成绑定文件，将这些文件同V8引擎一起编译。WebKit中使用IDL来定义JavaScript，但又与IDL有所不同，有一些改变。定义一个新的接口的步骤大致如下：</p><blockquote><p>1.定义新的接口文件，可以在JavaScript代码进行调用，如mymodule.MyObj.myAttr；</p></blockquote><pre><code>module mymodule {    interface [            InterfaceName = MyObject    ] MyObj {         readonly attribute long myAttr;        DOMString myMethod (DOMString myArg);    };}</code></pre><blockquote><p>2.按照引擎定义的标准接口为基础实现接口类，生成JavaScript引擎所需的绑定文件。WebKit提供了工具帮助生成所需的绑定类，根据引擎不同和引擎开发语言的不同而有所差异。V8引擎会为上述示例代码生成 v8MyObj.h (MyObj类具体的实现代码)和 V8MyObj.cpp (桥接代码，辅组注册桥接的函数到V8引擎)两个绑定文件。</p></blockquote><p>JavaScript引擎绑定机制需要将扩展代码和JavaScript引擎一块编译和打包，不能根据需要在引擎启动后再动态注入这些本地代码。在实际WEB开发中，开发者都是基于现有浏览器的，根本不可能介入到JavaScript引擎的编译中，绑定机制有很大的局限性，但其非常高效，适用于对性能要求较高的场景。</p><h3 id="4-2-Extension机制"><a href="#4-2-Extension机制" class="headerlink" title="4.2. Extension机制"></a>4.2. Extension机制</h3><p>通过V8的基类Extension进行能力扩展，无需和V8引擎一起编译，可以动态为引擎增加功能特性，具有很大的灵活性。</p><p>Extension机制的大致思路就是，V8提供一个基类Extension和一个全局注册函数，要想扩展JavaScript能力，需要经过以下步骤：</p><pre><code>class MYExtension : public v8::Extension {public:    MYExtension() : v8::Extension(&quot;v8/My&quot;, &quot;native function my();&quot;) {}    virtual v8::Handle&lt;v8::FunctionTemplate&gt; GetNativeFunction (    v8::Handle&lt;v8::String&gt; name) {        // 可以根据name来返回不同的函数        return v8::FunctionTemplate::New(MYExtention::MY);    }    static v8::Handle&lt;v8::Value&gt; MY(const v8::Arguments&amp; args) {        // Do sth here        return v8::Undefined();    }};MYExtension extension;RegisterExtension(&amp;extension);</code></pre><ol><li><p>基于Extension基类构建一个它的子类，并实现它的虚函数—GetNativeFunction，根据参数name来决定返回实函数；</p></li><li><p>创建一个该子类的对象，并通过注册函数将该对象注册到V8引擎，当JavaScript调用’my’函数时就可被调用到。</p></li></ol><p>Extension机制是调用V8的接口注入新函数，动态扩展非常方便，但没有绑定机制高效，适用于对性能要求不高的场景。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在过去几年，JavaScript在很多领域得到了广泛的应用，然而限于JavaScript语言本身的不足，执行效率不高。Google也推出了一些JavaScript网络应用，如Gmail、Google Maps及Google Docs office等。这些应用的性能不仅受到服务器、网络、渲染引擎以及其他诸多因素的影响，同时也受到JavaScript本身执行速度的影响。然而既有的JavaScript引擎无法满足新的需求，而性能不佳一直是网络应用开发者最关心的。Google就开始了V8引擎的研究，将一系列新技术引入JavaScript引擎中，大大提高了JavaScript的执行效率。相信随着V8引擎的不断发展，JavaScript也会有更广泛的应用场景，前端工程师也会有更好的未来！<br>那么结合上面对于V8引擎的介绍，我们在编程中应注意：</p><h3 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h3><p>对于函数，JavaScript是一种动态类型语言，JavaScriptCore和V8都使用隐藏类和内嵌缓存来提高性能，为了保证缓存命中率，一个函数应该使用较少的数据类型；对于数组，应尽量存放相同类型的数据，这样就可以通过偏移位置来访问。</p><h3 id="数据表示"><a href="#数据表示" class="headerlink" title="数据表示"></a>数据表示</h3><p>简单类型数据（如整型）直接保存在句柄中，可以减少寻址时间和内存占用，如果可以使用整数表示的，尽量不要用浮点类型。</p><h3 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h3><p>虽然JavaScript语言会自己进行垃圾回收，但我们也应尽量做到及时回收不用的内存，对不再使用的对象设置为null或使用delete方法来删除(使用delete方法删除会触发隐藏类新建，需要更多的额外操作)。</p><h3 id="优化回滚"><a href="#优化回滚" class="headerlink" title="优化回滚"></a>优化回滚</h3><p>在执行多次之后，不要出现修改对象类型的语句，尽量不要触发优化回滚，否则会大幅度降低代码的性能。<br>新机制。使用JavaScript引擎或者渲染引擎提供的新机制和新接口提高性能。</p><p>最后附上一个讲解Chrome中的javascript字节码缓存的视频</p><div style="position: relative; width: 100%; height: 0; padding-bottom: 75%;"><iframe src="//player.bilibili.com/player.html?aid=52517272&cid=91909420&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true" style="position: absolute; width:100%; height:100%;left:0;top:0;"> </iframe></div><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ul><li>《WebKit技术内幕》</li><li>《JavaScript高级程序设计》</li><li>《深入浅出Node.js》</li><li>《为什么V8引擎这么快》</li><li>《V8 Ignition：JS 引擎与字节码的不解之缘》</li></ul><p>原文链接：<a href="https://blog.csdn.net/heyeqingquan/article/details/78839699" target="_blank" rel="noopener">Chrome V8引擎介绍</a></p>]]></content>
      
      
      <categories>
          
          <category> 影音技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> chrome </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
